(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["phoenix_live_view"] = factory();
	else
		root["phoenix_live_view"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/phoenix_live_view.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/phoenix_live_view.js-exposed":
/*!*****************************************!*\
  !*** ./js/phoenix_live_view.js-exposed ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {if(!global[\"Phoenix\"]) global[\"Phoenix\"] = {};\nmodule.exports = global[\"Phoenix\"][\"LiveView\"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./phoenix_live_view.js */ \"./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js-exposed?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./js/phoenix_live_view.js ***!
  \*****************************************************************/
/*! exports provided: debug, Rendered, LiveSocket, Browser, DOM, View, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return debug; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rendered\", function() { return Rendered; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiveSocket\", function() { return LiveSocket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Browser\", function() { return Browser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOM\", function() { return DOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony import */ var morphdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! morphdom */ \"./node_modules/morphdom/dist/morphdom-esm.js\");\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n================================================================================\nPhoenix LiveView JavaScript Client\n================================================================================\n\nSee the hexdocs at `https://hexdocs.pm/phoenix_live_view` for documentation.\n\n*/\n\nvar CONSECUTIVE_RELOADS = \"consecutive-reloads\";\nvar MAX_RELOADS = 10;\nvar RELOAD_JITTER = [1000, 3000];\nvar FAILSAFE_JITTER = 30000;\nvar PHX_VIEW = \"data-phx-view\";\nvar PHX_EVENT_CLASSES = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"];\nvar PHX_COMPONENT = \"data-phx-component\";\nvar PHX_LIVE_LINK = \"data-phx-link\";\nvar PHX_TRACK_STATIC = \"track-static\";\nvar PHX_LINK_STATE = \"data-phx-link-state\";\nvar PHX_REF = \"data-phx-ref\";\nvar PHX_SKIP = \"data-phx-skip\";\nvar PHX_REMOVE = \"data-phx-remove\";\nvar PHX_PAGE_LOADING = \"page-loading\";\nvar PHX_CONNECTED_CLASS = \"phx-connected\";\nvar PHX_DISCONNECTED_CLASS = \"phx-disconnected\";\nvar PHX_NO_FEEDBACK_CLASS = \"phx-no-feedback\";\nvar PHX_ERROR_CLASS = \"phx-error\";\nvar PHX_PARENT_ID = \"data-phx-parent-id\";\nvar PHX_VIEW_SELECTOR = \"[\".concat(PHX_VIEW, \"]\");\nvar PHX_MAIN = \"data-phx-main\";\nvar PHX_ROOT_ID = \"data-phx-root-id\";\nvar PHX_TRIGGER_ACTION = \"trigger-action\";\nvar PHX_FEEDBACK_FOR = \"feedback-for\";\nvar PHX_HAS_FOCUSED = \"phx-has-focused\";\nvar FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"];\nvar CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\nvar PHX_HAS_SUBMITTED = \"phx-has-submitted\";\nvar PHX_SESSION = \"data-phx-session\";\nvar PHX_STATIC = \"data-phx-static\";\nvar PHX_READONLY = \"data-phx-readonly\";\nvar PHX_DISABLED = \"data-phx-disabled\";\nvar PHX_DISABLE_WITH = \"disable-with\";\nvar PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\nvar PHX_HOOK = \"hook\";\nvar PHX_DEBOUNCE = \"debounce\";\nvar PHX_THROTTLE = \"throttle\";\nvar PHX_UPDATE = \"update\";\nvar PHX_KEY = \"key\";\nvar PHX_PRIVATE = \"phxPrivate\";\nvar PHX_AUTO_RECOVER = \"auto-recover\";\nvar PHX_LV_DEBUG = \"phx:live-socket:debug\";\nvar PHX_LV_PROFILE = \"phx:live-socket:profiling\";\nvar PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\nvar LOADER_TIMEOUT = 1;\nvar BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\nvar BINDING_PREFIX = \"phx-\";\nvar PUSH_TIMEOUT = 30000;\nvar LINK_HEADER = \"x-requested-with\";\nvar RESPONSE_URL_HEADER = \"x-response-url\";\nvar DEBOUNCE_TRIGGER = \"debounce-trigger\";\nvar THROTTLED = \"throttled\";\nvar DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\nvar DEFAULTS = {\n  debounce: 300,\n  throttle: 300\n}; // Rendered\n\nvar DYNAMICS = \"d\";\nvar STATIC = \"s\";\nvar COMPONENTS = \"c\";\nvar EVENTS = \"e\";\nvar REPLY = \"r\";\nvar TITLE = \"t\";\n\nvar logError = function logError(msg, obj) {\n  return console.error && console.error(msg, obj);\n};\n\nfunction detectDuplicateIds() {\n  var ids = new Set();\n  var elems = document.querySelectorAll('*[id]');\n\n  for (var i = 0, len = elems.length; i < len; i++) {\n    if (ids.has(elems[i].id)) {\n      console.error(\"Multiple IDs detected: \".concat(elems[i].id, \". Ensure unique element ids.\"));\n    } else {\n      ids.add(elems[i].id);\n    }\n  }\n}\n\nvar debug = function debug(view, kind, msg, obj) {\n  if (view.liveSocket.isDebugEnabled()) {\n    console.log(\"\".concat(view.id, \" \").concat(kind, \": \").concat(msg, \" - \"), obj);\n  }\n}; // wraps value in closure or returns closure\n\nvar closure = function closure(val) {\n  return typeof val === \"function\" ? val : function () {\n    return val;\n  };\n};\n\nvar clone = function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nvar closestPhxBinding = function closestPhxBinding(el, binding, borderEl) {\n  do {\n    if (el.matches(\"[\".concat(binding, \"]\"))) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\n\n  return null;\n};\n\nvar isObject = function isObject(obj) {\n  return obj !== null && _typeof(obj) === \"object\" && !(obj instanceof Array);\n};\n\nvar isEqualObj = function isEqualObj(obj1, obj2) {\n  return JSON.stringify(obj1) === JSON.stringify(obj2);\n};\n\nvar isEmpty = function isEmpty(obj) {\n  for (var x in obj) {\n    return false;\n  }\n\n  return true;\n};\n\nvar maybe = function maybe(el, callback) {\n  return el && callback(el);\n};\n\nvar serializeForm = function serializeForm(form) {\n  var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = new FormData(form);\n  var params = new URLSearchParams();\n\n  var _iterator = _createForOfIteratorHelper(formData.entries()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          val = _step$value[1];\n\n      params.append(key, val);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  for (var metaKey in meta) {\n    params.append(metaKey, meta[metaKey]);\n  }\n\n  return params.toString();\n};\n\nvar Rendered = /*#__PURE__*/function () {\n  _createClass(Rendered, null, [{\n    key: \"extract\",\n    value: function extract(diff) {\n      var reply = diff[REPLY],\n          events = diff[EVENTS],\n          title = diff[TITLE];\n      delete diff[REPLY];\n      delete diff[EVENTS];\n      delete diff[TITLE];\n      return {\n        diff: diff,\n        title: title,\n        reply: reply || null,\n        events: events || []\n      };\n    }\n  }]);\n\n  function Rendered(viewId, rendered) {\n    _classCallCheck(this, Rendered);\n\n    this.viewId = viewId;\n    this.rendered = {};\n    this.mergeDiff(rendered);\n  }\n\n  _createClass(Rendered, [{\n    key: \"parentViewId\",\n    value: function parentViewId() {\n      return this.viewId;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(onlyCids) {\n      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);\n    }\n  }, {\n    key: \"recursiveToString\",\n    value: function recursiveToString(rendered) {\n      var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rendered[COMPONENTS];\n      var onlyCids = arguments.length > 2 ? arguments[2] : undefined;\n      onlyCids = onlyCids ? new Set(onlyCids) : null;\n      var output = {\n        buffer: \"\",\n        components: components,\n        onlyCids: onlyCids\n      };\n      this.toOutputBuffer(rendered, output);\n      return output.buffer;\n    }\n  }, {\n    key: \"componentCIDs\",\n    value: function componentCIDs(diff) {\n      return Object.keys(diff[COMPONENTS] || {}).map(function (i) {\n        return parseInt(i);\n      });\n    }\n  }, {\n    key: \"isComponentOnlyDiff\",\n    value: function isComponentOnlyDiff(diff) {\n      if (!diff[COMPONENTS]) {\n        return false;\n      }\n\n      return Object.keys(diff).length === 1;\n    }\n  }, {\n    key: \"getComponent\",\n    value: function getComponent(diff, cid) {\n      return diff[COMPONENTS][cid];\n    }\n  }, {\n    key: \"mergeDiff\",\n    value: function mergeDiff(diff) {\n      var newc = diff[COMPONENTS];\n      delete diff[COMPONENTS];\n      this.rendered = this.recursiveMerge(this.rendered, diff);\n      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n\n      if (newc) {\n        var oldc = this.rendered[COMPONENTS];\n\n        for (var cid in newc) {\n          var cdiff = newc[cid];\n          var component = cdiff;\n          var stat = component[STATIC];\n\n          if (typeof stat === \"number\") {\n            while (typeof stat === \"number\") {\n              component = stat > 0 ? newc[stat] : oldc[-stat];\n              stat = component[STATIC];\n            } // We need to clone because multiple components may point\n            // to the same shared component, and since recursive merge\n            // is destructive, we need to keep the original intact.\n            //\n            // Then we do a direct recursive merge because we always\n            // want to merge the first level, even if cdiff[STATIC]\n            // is not undefined. We put the proper static in place after\n            // merge.\n            //\n            // The test suite covers those corner cases.\n\n\n            component = clone(component);\n            this.doRecursiveMerge(component, cdiff);\n            component[STATIC] = stat;\n          } else {\n            component = oldc[cid] || {};\n            component = this.recursiveMerge(component, cdiff);\n          }\n\n          newc[cid] = component;\n        }\n\n        for (var key in newc) {\n          oldc[key] = newc[key];\n        }\n\n        diff[COMPONENTS] = newc;\n      }\n    }\n  }, {\n    key: \"recursiveMerge\",\n    value: function recursiveMerge(target, source) {\n      if (source[STATIC] !== undefined) {\n        return source;\n      } else {\n        this.doRecursiveMerge(target, source);\n        return target;\n      }\n    }\n  }, {\n    key: \"doRecursiveMerge\",\n    value: function doRecursiveMerge(target, source) {\n      for (var key in source) {\n        var val = source[key];\n        var targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === undefined && isObject(targetVal)) {\n          this.doRecursiveMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n  }, {\n    key: \"componentToString\",\n    value: function componentToString(cid) {\n      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);\n    }\n  }, {\n    key: \"pruneCIDs\",\n    value: function pruneCIDs(cids) {\n      var _this = this;\n\n      cids.forEach(function (cid) {\n        return delete _this.rendered[COMPONENTS][cid];\n      });\n    } // private\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this.rendered;\n    }\n  }, {\n    key: \"isNewFingerprint\",\n    value: function isNewFingerprint() {\n      var diff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return !!diff[STATIC];\n    }\n  }, {\n    key: \"toOutputBuffer\",\n    value: function toOutputBuffer(rendered, output) {\n      if (rendered[DYNAMICS]) {\n        return this.comprehensionToBuffer(rendered, output);\n      }\n\n      var statics = rendered[STATIC];\n      output.buffer += statics[0];\n\n      for (var i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(rendered[i - 1], output);\n        output.buffer += statics[i];\n      }\n    }\n  }, {\n    key: \"comprehensionToBuffer\",\n    value: function comprehensionToBuffer(rendered, output) {\n      var dynamics = rendered[DYNAMICS],\n          statics = rendered[STATIC];\n\n      for (var d = 0; d < dynamics.length; d++) {\n        var dynamic = dynamics[d];\n        output.buffer += statics[0];\n\n        for (var i = 1; i < statics.length; i++) {\n          this.dynamicToBuffer(dynamic[i - 1], output);\n          output.buffer += statics[i];\n        }\n      }\n    }\n  }, {\n    key: \"dynamicToBuffer\",\n    value: function dynamicToBuffer(rendered, output) {\n      if (typeof rendered === \"number\") {\n        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);\n      } else if (isObject(rendered)) {\n        this.toOutputBuffer(rendered, output);\n      } else {\n        output.buffer += rendered;\n      }\n    }\n  }, {\n    key: \"recursiveCIDToString\",\n    value: function recursiveCIDToString(components, cid, onlyCids) {\n      var _this2 = this;\n\n      var component = components[cid] || logError(\"no component for CID \".concat(cid), components);\n      var template = document.createElement(\"template\");\n      template.innerHTML = this.recursiveToString(component, components, onlyCids);\n      var container = template.content;\n      var skip = onlyCids && !onlyCids.has(cid);\n\n      var _Array$from$reduce = Array.from(container.childNodes).reduce(function (_ref, child, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            hasNodes = _ref2[0],\n            hasComponents = _ref2[1];\n\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          if (child.getAttribute(PHX_COMPONENT)) {\n            return [hasNodes, true];\n          }\n\n          child.setAttribute(PHX_COMPONENT, cid);\n\n          if (!child.id) {\n            child.id = \"\".concat(_this2.parentViewId(), \"-\").concat(cid, \"-\").concat(i);\n          }\n\n          if (skip) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n\n          return [true, hasComponents];\n        } else {\n          if (child.nodeValue.trim() !== \"\") {\n            logError(\"only HTML element tags are allowed at the root of components.\\n\\n\" + \"got: \\\"\".concat(child.nodeValue.trim(), \"\\\"\\n\\n\") + \"within:\\n\", template.innerHTML.trim());\n            child.replaceWith(_this2.createSpan(child.nodeValue, cid));\n            return [true, hasComponents];\n          } else {\n            child.remove();\n            return [hasNodes, hasComponents];\n          }\n        }\n      }, [false, false]),\n          _Array$from$reduce2 = _slicedToArray(_Array$from$reduce, 2),\n          hasChildNodes = _Array$from$reduce2[0],\n          hasChildComponents = _Array$from$reduce2[1];\n\n      if (!hasChildNodes && !hasChildComponents) {\n        logError(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", template.innerHTML.trim());\n        return this.createSpan(\"\", cid).outerHTML;\n      } else if (!hasChildNodes && hasChildComponents) {\n        logError(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", template.innerHTML.trim());\n        return template.innerHTML;\n      } else {\n        return template.innerHTML;\n      }\n    }\n  }, {\n    key: \"createSpan\",\n    value: function createSpan(text, cid) {\n      var span = document.createElement(\"span\");\n      span.innerText = text;\n      span.setAttribute(PHX_COMPONENT, cid);\n      return span;\n    }\n  }]);\n\n  return Rendered;\n}();\n/** Initializes the LiveSocket\n *\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"wss://example.com/live\"`,\n *                                               `\"/live\"` (inherited host & protocol)\n * @param {Phoenix.Socket} socket - the required Phoenix Socket class imported from \"phoenix\". For example:\n *\n *     import {Socket} from \"phoenix\"\n *     import {LiveSocket} from \"phoenix_live_view\"\n *     let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n *\n * @param {Object} [opts] - Optional configuration. Outside of keys listed below, all\n * configuration is passed directly to the Phoenix Socket constructor.\n * @param {Object} [opts.defaults] - The optional defaults to use for various bindings,\n * such as `phx-debounce`. Supports the following keys:\n *\n *   - debounce - the millisecond phx-debounce time. Defaults 300\n *   - throttle - the millisecond phx-throttle time. Defaults 300\n *\n * @param {Function} [opts.params] - The optional function for passing connect params.\n * The function receives the viewName associated with a given LiveView. For example:\n *\n *     (viewName) => {view: viewName, token: window.myToken}\n *\n * @param {string} [opts.bindingPrefix] - The optional prefix to use for all phx DOM annotations.\n * Defaults to \"phx-\".\n * @param {Object} [opts.hooks] - The optional object for referencing LiveView hook callbacks.\n * @param {integer} [opts.loaderTimeout] - The optional delay in milliseconds to wait before apply\n * loading states.\n * @param {Function} [opts.viewLogger] - The optional function to log debug information. For example:\n *\n *     (view, kind, msg, obj) => console.log(`${view.id} ${kind}: ${msg} - `, obj)\n *\n * @param {Object} [opts.metadata] - The optional object mapping event names to functions for\n * populating event metadata. For example:\n *\n *     metadata: {\n *       click: (e, el) => {\n *         return {\n *           ctrlKey: e.ctrlKey,\n *           metaKey: e.metaKey,\n *           detail: e.detail || 1,\n *         }\n *       },\n *       keydown: (e, el) => {\n *         return {\n *           key: e.key,\n *           ctrlKey: e.ctrlKey,\n *           metaKey: e.metaKey,\n *           shiftKey: e.shiftKey\n *         }\n *       }\n *     }\n*/\n\nvar LiveSocket = /*#__PURE__*/function () {\n  function LiveSocket(url, phxSocket) {\n    var _this3 = this;\n\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, LiveSocket);\n\n    this.unloaded = false;\n\n    if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n      throw new Error(\"\\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\\n\\n          import {Socket} from \\\"phoenix\\\"\\n          import {LiveSocket} from \\\"phoenix_live_view\\\"\\n          let liveSocket = new LiveSocket(\\\"/live\\\", Socket, {...})\\n      \");\n    }\n\n    this.socket = new phxSocket(url, opts);\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n    this.opts = opts;\n    this.params = closure(opts.params || {});\n    this.viewLogger = opts.viewLogger;\n    this.metadataCallbacks = opts.metadata || {};\n    this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n    this.activeElement = null;\n    this.prevActive = null;\n    this.silenced = false;\n    this.main = null;\n    this.linkRef = 0;\n    this.roots = {};\n    this.href = window.location.href;\n    this.pendingLink = null;\n    this.currentLocation = clone(window.location);\n    this.hooks = opts.hooks || {};\n    this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n    this.boundTopLevelEvents = false;\n    this.domCallbacks = opts.dom || {\n      onBeforeElUpdated: closure()\n    };\n    window.addEventListener(\"unload\", function (e) {\n      _this3.unloaded = true;\n    });\n    this.socket.onOpen(function () {\n      if (_this3.isUnloaded()) {\n        // reload page if being restored from back/forward cache and browser does not emit \"pageshow\"\n        window.location.reload();\n      }\n    });\n  } // public\n\n\n  _createClass(LiveSocket, [{\n    key: \"isProfileEnabled\",\n    value: function isProfileEnabled() {\n      return sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n    }\n  }, {\n    key: \"isDebugEnabled\",\n    value: function isDebugEnabled() {\n      return sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n    }\n  }, {\n    key: \"enableDebug\",\n    value: function enableDebug() {\n      sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n    }\n  }, {\n    key: \"enableProfiling\",\n    value: function enableProfiling() {\n      sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n    }\n  }, {\n    key: \"disableDebug\",\n    value: function disableDebug() {\n      sessionStorage.removeItem(PHX_LV_DEBUG);\n    }\n  }, {\n    key: \"disableProfiling\",\n    value: function disableProfiling() {\n      sessionStorage.removeItem(PHX_LV_PROFILE);\n    }\n  }, {\n    key: \"enableLatencySim\",\n    value: function enableLatencySim(upperBoundMs) {\n      this.enableDebug();\n      console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\");\n      sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n    }\n  }, {\n    key: \"disableLatencySim\",\n    value: function disableLatencySim() {\n      sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n    }\n  }, {\n    key: \"getLatencySim\",\n    value: function getLatencySim() {\n      var str = sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n      return str ? parseInt(str) : null;\n    }\n  }, {\n    key: \"getSocket\",\n    value: function getSocket() {\n      return this.socket;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this4 = this;\n\n      var doConnect = function doConnect() {\n        if (_this4.joinRootViews()) {\n          _this4.bindTopLevelEvents();\n\n          _this4.socket.connect();\n        }\n      };\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        doConnect();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", function () {\n          return doConnect();\n        });\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback) {\n      this.socket.disconnect(callback);\n    } // private\n\n  }, {\n    key: \"triggerDOM\",\n    value: function triggerDOM(kind, args) {\n      var _this$domCallbacks;\n\n      (_this$domCallbacks = this.domCallbacks)[kind].apply(_this$domCallbacks, _toConsumableArray(args));\n    }\n  }, {\n    key: \"time\",\n    value: function time(name, func) {\n      if (!this.isProfileEnabled() || !console.time) {\n        return func();\n      }\n\n      console.time(name);\n      var result = func();\n      console.timeEnd(name);\n      return result;\n    }\n  }, {\n    key: \"log\",\n    value: function log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        var _msgCallback = msgCallback(),\n            _msgCallback2 = _slicedToArray(_msgCallback, 2),\n            msg = _msgCallback2[0],\n            obj = _msgCallback2[1];\n\n        this.viewLogger(view, kind, msg, obj);\n      } else if (this.isDebugEnabled()) {\n        var _msgCallback3 = msgCallback(),\n            _msgCallback4 = _slicedToArray(_msgCallback3, 2),\n            _msg = _msgCallback4[0],\n            _obj = _msgCallback4[1];\n\n        debug(view, kind, _msg, _obj);\n      }\n    }\n  }, {\n    key: \"onChannel\",\n    value: function onChannel(channel, event, cb) {\n      var _this5 = this;\n\n      channel.on(event, function (data) {\n        var latency = _this5.getLatencySim();\n\n        if (!latency) {\n          cb(data);\n        } else {\n          console.log(\"simulating \".concat(latency, \"ms of latency from server to client\"));\n          setTimeout(function () {\n            return cb(data);\n          }, latency);\n        }\n      });\n    }\n  }, {\n    key: \"wrapPush\",\n    value: function wrapPush(push) {\n      var latency = this.getLatencySim();\n\n      if (!latency) {\n        return push();\n      }\n\n      console.log(\"simulating \".concat(latency, \"ms of latency from client to server\"));\n      var fakePush = {\n        receives: [],\n        receive: function receive(kind, cb) {\n          this.receives.push([kind, cb]);\n        }\n      };\n      setTimeout(function () {\n        fakePush.receives.reduce(function (acc, _ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              kind = _ref4[0],\n              cb = _ref4[1];\n\n          return acc.receive(kind, cb);\n        }, push());\n      }, latency);\n      return fakePush;\n    }\n  }, {\n    key: \"reloadWithJitter\",\n    value: function reloadWithJitter(view) {\n      var _this6 = this;\n\n      view.destroy();\n      this.disconnect();\n      var minMs = RELOAD_JITTER[0],\n          maxMs = RELOAD_JITTER[1];\n      var afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n      var tries = Browser.updateLocal(view.name(), CONSECUTIVE_RELOADS, 0, function (count) {\n        return count + 1;\n      });\n      this.log(view, \"join\", function () {\n        return [\"encountered \".concat(tries, \" consecutive reloads\")];\n      });\n\n      if (tries > MAX_RELOADS) {\n        this.log(view, \"join\", function () {\n          return [\"exceeded \".concat(MAX_RELOADS, \" consecutive reloads. Entering failsafe mode\")];\n        });\n        afterMs = FAILSAFE_JITTER;\n      }\n\n      setTimeout(function () {\n        if (_this6.hasPendingLink()) {\n          window.location = _this6.pendingLink;\n        } else {\n          window.location.reload();\n        }\n      }, afterMs);\n    }\n  }, {\n    key: \"getHookCallbacks\",\n    value: function getHookCallbacks(hookName) {\n      return this.hooks[hookName];\n    }\n  }, {\n    key: \"isUnloaded\",\n    value: function isUnloaded() {\n      return this.unloaded;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.socket.isConnected();\n    }\n  }, {\n    key: \"getBindingPrefix\",\n    value: function getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return \"\".concat(this.getBindingPrefix()).concat(kind);\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic, params) {\n      return this.socket.channel(topic, params);\n    }\n  }, {\n    key: \"joinRootViews\",\n    value: function joinRootViews() {\n      var _this7 = this;\n\n      var rootsFound = false;\n      DOM.all(document, \"\".concat(PHX_VIEW_SELECTOR, \":not([\").concat(PHX_PARENT_ID, \"])\"), function (rootEl) {\n        if (!_this7.getRootById(rootEl.id)) {\n          var view = _this7.joinRootView(rootEl, _this7.getHref());\n\n          _this7.root = _this7.root || view;\n\n          if (rootEl.getAttribute(PHX_MAIN)) {\n            _this7.main = view;\n          }\n        }\n\n        rootsFound = true;\n      });\n      return rootsFound;\n    }\n  }, {\n    key: \"redirect\",\n    value: function redirect(to, flash) {\n      this.disconnect();\n      Browser.redirect(to, flash);\n    }\n  }, {\n    key: \"replaceMain\",\n    value: function replaceMain(href, flash) {\n      var _this8 = this;\n\n      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var linkRef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.setPendingLink(href);\n      var mainEl = this.main.el;\n      this.main.showLoader(this.loaderTimeout);\n      this.main.destroy();\n      Browser.fetchPage(href, function (status, html) {\n        if (status !== 200) {\n          return _this8.redirect(href);\n        }\n\n        var template = document.createElement(\"template\");\n        template.innerHTML = html;\n        var el = template.content.childNodes[0];\n\n        if (!el || !_this8.isPhxView(el)) {\n          return _this8.redirect(href);\n        }\n\n        _this8.joinRootView(el, href, flash, function (newMain, joinCount) {\n          if (joinCount !== 1) {\n            return;\n          }\n\n          if (!_this8.commitPendingLink(linkRef)) {\n            newMain.destroy();\n            return;\n          }\n\n          mainEl.replaceWith(newMain.el);\n          _this8.main = newMain;\n          callback && callback();\n        });\n      });\n    }\n  }, {\n    key: \"isPhxView\",\n    value: function isPhxView(el) {\n      return el.getAttribute && el.getAttribute(PHX_VIEW) !== null;\n    }\n  }, {\n    key: \"joinRootView\",\n    value: function joinRootView(el, href, flash, callback) {\n      var view = new View(el, this, null, href, flash);\n      this.roots[view.id] = view;\n      view.join(callback);\n      return view;\n    }\n  }, {\n    key: \"owner\",\n    value: function owner(childEl, callback) {\n      var _this9 = this;\n\n      var view = maybe(childEl.closest(PHX_VIEW_SELECTOR), function (el) {\n        return _this9.getViewByEl(el);\n      });\n\n      if (view) {\n        callback(view);\n      }\n    }\n  }, {\n    key: \"withinOwners\",\n    value: function withinOwners(childEl, callback) {\n      var _this10 = this;\n\n      this.owner(childEl, function (view) {\n        var phxTarget = childEl.getAttribute(_this10.binding(\"target\"));\n\n        if (phxTarget === null) {\n          callback(view, childEl);\n        } else {\n          view.withinTargets(phxTarget, callback);\n        }\n      });\n    }\n  }, {\n    key: \"getViewByEl\",\n    value: function getViewByEl(el) {\n      var rootId = el.getAttribute(PHX_ROOT_ID);\n      return maybe(this.getRootById(rootId), function (root) {\n        return root.getDescendentByEl(el);\n      });\n    }\n  }, {\n    key: \"getRootById\",\n    value: function getRootById(id) {\n      return this.roots[id];\n    }\n  }, {\n    key: \"destroyAllViews\",\n    value: function destroyAllViews() {\n      for (var id in this.roots) {\n        this.roots[id].destroy();\n        delete this.roots[id];\n      }\n    }\n  }, {\n    key: \"destroyViewByEl\",\n    value: function destroyViewByEl(el) {\n      var root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n\n      if (root) {\n        root.destroyDescendent(el.id);\n      }\n    }\n  }, {\n    key: \"setActiveElement\",\n    value: function setActiveElement(target) {\n      var _this11 = this;\n\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      var cancel = function cancel() {\n        if (target === _this11.activeElement) {\n          _this11.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", _this11);\n        target.removeEventListener(\"touchend\", _this11);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n  }, {\n    key: \"getActiveElement\",\n    value: function getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        // document.activeElement can be null in Internet Explorer 11\n        return document.activeElement || document.body;\n      }\n    }\n  }, {\n    key: \"dropActiveElement\",\n    value: function dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n  }, {\n    key: \"restorePreviouslyActiveFocus\",\n    value: function restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n  }, {\n    key: \"bindTopLevelEvents\",\n    value: function bindTopLevelEvents() {\n      var _this12 = this;\n\n      if (this.boundTopLevelEvents) {\n        return;\n      }\n\n      this.boundTopLevelEvents = true;\n      window.addEventListener(\"pageshow\", function (e) {\n        if (e.persisted) {\n          // reload page if being restored from back/forward cache\n          _this12.withPageLoading({\n            to: window.location.href,\n            kind: \"redirect\"\n          });\n\n          window.location.reload();\n        }\n      });\n      this.bindClicks();\n      this.bindNav();\n      this.bindForms();\n      this.bind({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, function (e, type, view, target, targetCtx, phxEvent, phxTarget) {\n        var matchKey = target.getAttribute(_this12.binding(PHX_KEY));\n        var pressedKey = e.key && e.key.toLowerCase(); // chrome clicked autocompletes send a keydown without key\n\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n\n        view.pushKey(target, targetCtx, type, phxEvent, _objectSpread({\n          key: e.key\n        }, _this12.eventMeta(type, e, target)));\n      });\n      this.bind({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, function (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) {\n        if (!phxTarget) {\n          view.pushEvent(type, targetEl, targetCtx, phxEvent, _this12.eventMeta(type, e, targetEl));\n        }\n      });\n      this.bind({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, function (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) {\n        // blur and focus are triggered on document and window. Discard one to avoid dups\n        if (phxTarget && !phxTarget !== \"window\") {\n          view.pushEvent(type, targetEl, targetCtx, phxEvent, _this12.eventMeta(type, e, targetEl));\n        }\n      });\n    }\n  }, {\n    key: \"eventMeta\",\n    value: function eventMeta(eventName, e, targetEl) {\n      var callback = this.metadataCallbacks[eventName];\n      return callback ? callback(e, targetEl) : {};\n    }\n  }, {\n    key: \"setPendingLink\",\n    value: function setPendingLink(href) {\n      this.linkRef++;\n      this.pendingLink = href;\n      return this.linkRef;\n    }\n  }, {\n    key: \"commitPendingLink\",\n    value: function commitPendingLink(linkRef) {\n      if (this.linkRef !== linkRef) {\n        return false;\n      } else {\n        this.href = this.pendingLink;\n        this.pendingLink = null;\n        return true;\n      }\n    }\n  }, {\n    key: \"getHref\",\n    value: function getHref() {\n      return this.href;\n    }\n  }, {\n    key: \"hasPendingLink\",\n    value: function hasPendingLink() {\n      return !!this.pendingLink;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(events, callback) {\n      var _this13 = this;\n\n      var _loop = function _loop(event) {\n        var browserEventName = events[event];\n\n        _this13.on(browserEventName, function (e) {\n          var binding = _this13.binding(event);\n\n          var windowBinding = _this13.binding(\"window-\".concat(event));\n\n          var targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent) {\n            _this13.debounce(e.target, e, function () {\n              _this13.withinOwners(e.target, function (view, targetCtx) {\n                callback(e, event, view, e.target, targetCtx, targetPhxEvent, null);\n              });\n            });\n          } else {\n            DOM.all(document, \"[\".concat(windowBinding, \"]\"), function (el) {\n              var phxEvent = el.getAttribute(windowBinding);\n\n              _this13.debounce(el, e, function () {\n                _this13.withinOwners(el, function (view, targetCtx) {\n                  callback(e, event, view, el, targetCtx, phxEvent, \"window\");\n                });\n              });\n            });\n          }\n        });\n      };\n\n      for (var event in events) {\n        _loop(event);\n      }\n    }\n  }, {\n    key: \"bindClicks\",\n    value: function bindClicks() {\n      var _this14 = this;\n\n      [true, false].forEach(function (capture) {\n        var click = capture ? _this14.binding(\"capture-click\") : _this14.binding(\"click\");\n        window.addEventListener(\"click\", function (e) {\n          var target = null;\n\n          if (capture) {\n            target = e.target.matches(\"[\".concat(click, \"]\")) ? e.target : e.target.querySelector(\"[\".concat(click, \"]\"));\n          } else {\n            target = closestPhxBinding(e.target, click);\n          }\n\n          var phxEvent = target && target.getAttribute(click);\n\n          if (!phxEvent) {\n            return;\n          }\n\n          if (target.getAttribute(\"href\") === \"#\") {\n            e.preventDefault();\n          }\n\n          _this14.debounce(target, e, function () {\n            _this14.withinOwners(target, function (view, targetCtx) {\n              view.pushEvent(\"click\", target, targetCtx, phxEvent, _this14.eventMeta(\"click\", e, target));\n            });\n          });\n        }, capture);\n      });\n    }\n  }, {\n    key: \"bindNav\",\n    value: function bindNav() {\n      var _this15 = this;\n\n      if (!Browser.canPushState()) {\n        return;\n      }\n\n      window.addEventListener(\"popstate\", function (event) {\n        if (!_this15.registerNewLocation(window.location)) {\n          return;\n        }\n\n        var _ref5 = event.state || {},\n            type = _ref5.type,\n            id = _ref5.id,\n            root = _ref5.root,\n            scroll = _ref5.scroll;\n\n        var href = window.location.href;\n\n        if (_this15.main.isConnected() && type === \"patch\" && id === _this15.main.id) {\n          _this15.main.pushLinkPatch(href, null);\n        } else {\n          _this15.replaceMain(href, null, function () {\n            if (root) {\n              _this15.replaceRootHistory();\n            }\n\n            if (scroll) {\n              setTimeout(function () {\n                window.scrollTo(0, scroll);\n              }, 1); // the body needs to render before we scroll. \n            }\n          });\n        }\n      }, false);\n      window.addEventListener(\"click\", function (e) {\n        var target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        var type = target && target.getAttribute(PHX_LIVE_LINK);\n        var wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;\n\n        if (!type || !_this15.isConnected() || !_this15.main || wantsNewTab) {\n          return;\n        }\n\n        var href = target.href;\n        var linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n\n        if (_this15.pendingLink === href) {\n          return;\n        }\n\n        if (type === \"patch\") {\n          _this15.pushHistoryPatch(href, linkState, target);\n        } else if (type === \"redirect\") {\n          _this15.historyRedirect(href, linkState);\n        } else {\n          throw new Error(\"expected \".concat(PHX_LIVE_LINK, \" to be \\\"patch\\\" or \\\"redirect\\\", got: \").concat(type));\n        }\n      }, false);\n    }\n  }, {\n    key: \"withPageLoading\",\n    value: function withPageLoading(info, callback) {\n      DOM.dispatchEvent(window, \"phx:page-loading-start\", info);\n\n      var done = function done() {\n        return DOM.dispatchEvent(window, \"phx:page-loading-stop\", info);\n      };\n\n      return callback ? callback(done) : done;\n    }\n  }, {\n    key: \"pushHistoryPatch\",\n    value: function pushHistoryPatch(href, linkState, targetEl) {\n      var _this16 = this;\n\n      this.withPageLoading({\n        to: href,\n        kind: \"patch\"\n      }, function (done) {\n        _this16.main.pushLinkPatch(href, targetEl, function () {\n          _this16.historyPatch(href, linkState);\n\n          done();\n        });\n      });\n    }\n  }, {\n    key: \"historyPatch\",\n    value: function historyPatch(href, linkState) {\n      Browser.pushState(linkState, {\n        type: \"patch\",\n        id: this.main.id\n      }, href);\n      this.registerNewLocation(window.location);\n    }\n  }, {\n    key: \"historyRedirect\",\n    value: function historyRedirect(href, linkState, flash) {\n      var _this17 = this;\n\n      var scroll = window.scrollY;\n      this.withPageLoading({\n        to: href,\n        kind: \"redirect\"\n      }, function (done) {\n        _this17.replaceMain(href, flash, function () {\n          Browser.pushState(linkState, {\n            type: \"redirect\",\n            id: _this17.main.id,\n            scroll: scroll\n          }, href);\n\n          _this17.registerNewLocation(window.location);\n\n          done();\n        });\n      });\n    }\n  }, {\n    key: \"replaceRootHistory\",\n    value: function replaceRootHistory() {\n      Browser.pushState(\"replace\", {\n        root: true,\n        type: \"patch\",\n        id: this.main.id\n      });\n    }\n  }, {\n    key: \"registerNewLocation\",\n    value: function registerNewLocation(newLocation) {\n      var _this$currentLocation = this.currentLocation,\n          pathname = _this$currentLocation.pathname,\n          search = _this$currentLocation.search;\n\n      if (pathname + search === newLocation.pathname + newLocation.search) {\n        return false;\n      } else {\n        this.currentLocation = clone(newLocation);\n        return true;\n      }\n    }\n  }, {\n    key: \"bindForms\",\n    value: function bindForms() {\n      var _this18 = this;\n\n      var iterations = 0;\n      this.on(\"submit\", function (e) {\n        var phxEvent = e.target.getAttribute(_this18.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n\n        _this18.withinOwners(e.target, function (view, targetCtx) {\n          return view.submitForm(e.target, targetCtx, phxEvent);\n        });\n      }, false);\n\n      var _loop2 = function _loop2() {\n        var type = _arr2[_i2];\n\n        _this18.on(type, function (e) {\n          var input = e.target;\n          var phxEvent = input.form && input.form.getAttribute(_this18.binding(\"change\"));\n\n          if (!phxEvent) {\n            return;\n          }\n\n          if (input.type === \"number\" && input.validity && input.validity.badInput) {\n            return;\n          }\n\n          var currentIterations = iterations;\n          iterations++;\n\n          var _ref6 = DOM[\"private\"](input, \"prev-iteration\") || {},\n              at = _ref6.at,\n              lastType = _ref6.type; // detect dup because some browsers dispatch both \"input\" and \"change\"\n\n\n          if (at === currentIterations - 1 && type !== lastType) {\n            return;\n          }\n\n          DOM.putPrivate(input, \"prev-iteration\", {\n            at: currentIterations,\n            type: type\n          });\n\n          _this18.debounce(input, e, function () {\n            _this18.withinOwners(input.form, function (view, targetCtx) {\n              DOM.putPrivate(input, PHX_HAS_FOCUSED, true);\n\n              if (!DOM.isTextualInput(input)) {\n                _this18.setActiveElement(input);\n              }\n\n              view.pushInput(input, targetCtx, phxEvent, e.target);\n            });\n          });\n        }, false);\n      };\n\n      for (var _i2 = 0, _arr2 = [\"change\", \"input\"]; _i2 < _arr2.length; _i2++) {\n        _loop2();\n      }\n    }\n  }, {\n    key: \"debounce\",\n    value: function debounce(el, event, callback) {\n      var phxDebounce = this.binding(PHX_DEBOUNCE);\n      var phxThrottle = this.binding(PHX_THROTTLE);\n      var defaultDebounce = this.defaults.debounce.toString();\n      var defaultThrottle = this.defaults.throttle.toString();\n      DOM.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);\n    }\n  }, {\n    key: \"silenceEvents\",\n    value: function silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      var _this19 = this;\n\n      window.addEventListener(event, function (e) {\n        if (!_this19.silenced) {\n          callback(e);\n        }\n      });\n    }\n  }]);\n\n  return LiveSocket;\n}();\nvar Browser = {\n  canPushState: function canPushState() {\n    return typeof history.pushState !== \"undefined\";\n  },\n  dropLocal: function dropLocal(namespace, subkey) {\n    return window.localStorage.removeItem(this.localKey(namespace, subkey));\n  },\n  updateLocal: function updateLocal(namespace, subkey, initial, func) {\n    var current = this.getLocal(namespace, subkey);\n    var key = this.localKey(namespace, subkey);\n    var newVal = current === null ? initial : func(current);\n    window.localStorage.setItem(key, JSON.stringify(newVal));\n    return newVal;\n  },\n  getLocal: function getLocal(namespace, subkey) {\n    return JSON.parse(window.localStorage.getItem(this.localKey(namespace, subkey)));\n  },\n  fetchPage: function fetchPage(href, callback) {\n    var req = new XMLHttpRequest();\n    req.open(\"GET\", href, true);\n    req.timeout = PUSH_TIMEOUT;\n    req.setRequestHeader(\"content-type\", \"text/html\");\n    req.setRequestHeader(\"cache-control\", \"max-age=0, no-cache, no-store, must-revalidate, post-check=0, pre-check=0\");\n    req.setRequestHeader(LINK_HEADER, \"live-link\");\n\n    req.onerror = function () {\n      return callback(400);\n    };\n\n    req.ontimeout = function () {\n      return callback(504);\n    };\n\n    req.onreadystatechange = function () {\n      if (req.readyState !== 4) {\n        return;\n      }\n\n      var requestURL = new URL(href);\n      var requestPath = requestURL.pathname + requestURL.search;\n      var responseURL = maybe(req.getResponseHeader(RESPONSE_URL_HEADER) || req.responseURL, function (url) {\n        return new URL(url);\n      });\n      var responsePath = responseURL ? responseURL.pathname + responseURL.search : null;\n\n      if (req.getResponseHeader(LINK_HEADER) !== \"live-link\") {\n        return callback(400);\n      } else if (responseURL === null || responsePath != requestPath) {\n        return callback(302);\n      } else if (req.status !== 200) {\n        return callback(req.status);\n      } else {\n        callback(200, req.responseText);\n      }\n    };\n\n    req.send();\n  },\n  pushState: function pushState(kind, meta, to) {\n    if (this.canPushState()) {\n      if (to !== window.location.href) {\n        if (meta.type == \"redirect\" && meta.scroll) {\n          // If we're redirecting store the window scroll in the history state\n          var currentState = history.state || {};\n          currentState.scroll = meta.scroll;\n          history.replaceState(currentState, \"\", window.location.href);\n        }\n\n        delete meta.scroll;\n        history[kind + \"State\"](meta, \"\", to || null); // IE will coerce undefined to string\n\n        var hashEl = this.getHashTargetEl(window.location.hash);\n\n        if (hashEl) {\n          hashEl.scrollIntoView();\n        } else if (meta.type === \"redirect\") {\n          window.scroll(0, 0);\n        }\n      }\n    } else {\n      this.redirect(to);\n    }\n  },\n  setCookie: function setCookie(name, value) {\n    document.cookie = \"\".concat(name, \"=\").concat(value);\n  },\n  getCookie: function getCookie(name) {\n    return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\".concat(name, \"s*=s*([^;]*).*$)|^.*$\")), \"$1\");\n  },\n  redirect: function redirect(toURL, flash) {\n    if (flash) {\n      Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n    }\n\n    window.location = toURL;\n  },\n  localKey: function localKey(namespace, subkey) {\n    return \"\".concat(namespace, \"-\").concat(subkey);\n  },\n  getHashTargetEl: function getHashTargetEl(hash) {\n    if (hash.toString() === \"\") {\n      return;\n    }\n\n    return document.getElementById(hash) || document.querySelector(\"a[name=\\\"\".concat(hash.substring(1), \"\\\"]\"));\n  }\n};\nvar DOM = {\n  byId: function byId(id) {\n    return document.getElementById(id) || logError(\"no id found for \".concat(id));\n  },\n  removeClass: function removeClass(el, className) {\n    el.classList.remove(className);\n\n    if (el.classList.length === 0) {\n      el.removeAttribute(\"class\");\n    }\n  },\n  all: function all(node, query, callback) {\n    var array = Array.from(node.querySelectorAll(query));\n    return callback ? array.forEach(callback) : array;\n  },\n  findComponentNodeList: function findComponentNodeList(node, cid) {\n    var phxChildren = this.all(node, PHX_VIEW_SELECTOR);\n    var result = this.all(node, \"[\".concat(PHX_COMPONENT, \"=\\\"\").concat(cid, \"\\\"]\"));\n\n    if (phxChildren.length === 0) {\n      return result;\n    } else {\n      return result.filter(function (element) {\n        return !phxChildren.some(function (node) {\n          return node.contains(element);\n        });\n      });\n    }\n  },\n  findPhxChildrenInFragment: function findPhxChildrenInFragment(html, parentId) {\n    var template = document.createElement(\"template\");\n    template.innerHTML = html;\n    return this.findPhxChildren(template.content, parentId);\n  },\n  isPhxUpdate: function isPhxUpdate(el, phxUpdate, updateTypes) {\n    return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\n  },\n  findPhxChildren: function findPhxChildren(el, parentId) {\n    return this.all(el, \"\".concat(PHX_VIEW_SELECTOR, \"[\").concat(PHX_PARENT_ID, \"=\\\"\").concat(parentId, \"\\\"]\"));\n  },\n  findParentCIDs: function findParentCIDs(node, cids) {\n    var _this20 = this;\n\n    var initial = new Set(cids);\n    return cids.reduce(function (acc, cid) {\n      var selector = \"[\".concat(PHX_COMPONENT, \"=\\\"\").concat(cid, \"\\\"] [\").concat(PHX_COMPONENT, \"]\");\n\n      _this20.all(node, selector).map(function (el) {\n        return parseInt(el.getAttribute(PHX_COMPONENT));\n      }).forEach(function (childCID) {\n        return acc[\"delete\"](childCID);\n      });\n\n      return acc;\n    }, initial);\n  },\n  \"private\": function _private(el, key) {\n    return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n  },\n  deletePrivate: function deletePrivate(el, key) {\n    el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n  },\n  putPrivate: function putPrivate(el, key, value) {\n    if (!el[PHX_PRIVATE]) {\n      el[PHX_PRIVATE] = {};\n    }\n\n    el[PHX_PRIVATE][key] = value;\n  },\n  copyPrivates: function copyPrivates(target, source) {\n    if (source[PHX_PRIVATE]) {\n      target[PHX_PRIVATE] = clone(source[PHX_PRIVATE]);\n    }\n  },\n  putTitle: function putTitle(str) {\n    var titleEl = document.querySelector(\"title\");\n    var _titleEl$dataset = titleEl.dataset,\n        prefix = _titleEl$dataset.prefix,\n        suffix = _titleEl$dataset.suffix;\n    document.title = \"\".concat(prefix || \"\").concat(str).concat(suffix || \"\");\n  },\n  debounce: function debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {\n    var _this21 = this;\n\n    var debounce = el.getAttribute(phxDebounce);\n    var throttle = el.getAttribute(phxThrottle);\n\n    if (debounce === \"\") {\n      debounce = defaultDebounce;\n    }\n\n    if (throttle === \"\") {\n      throttle = defaultThrottle;\n    }\n\n    var value = debounce || throttle;\n\n    switch (value) {\n      case null:\n        return callback();\n\n      case \"blur\":\n        if (this.once(el, \"debounce-blur\")) {\n          el.addEventListener(\"blur\", function () {\n            return callback();\n          });\n        }\n\n        return;\n\n      default:\n        var timeout = parseInt(value);\n\n        var trigger = function trigger() {\n          return throttle ? _this21.deletePrivate(el, THROTTLED) : callback();\n        };\n\n        var currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n\n        if (isNaN(timeout)) {\n          return logError(\"invalid throttle/debounce value: \".concat(value));\n        }\n\n        if (throttle) {\n          var newKeyDown = false;\n\n          if (event.type === \"keydown\") {\n            var prevKey = this[\"private\"](el, DEBOUNCE_PREV_KEY);\n            this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n            newKeyDown = prevKey !== event.key;\n          }\n\n          if (!newKeyDown && this[\"private\"](el, THROTTLED)) {\n            return false;\n          } else {\n            callback();\n            this.putPrivate(el, THROTTLED, true);\n            setTimeout(function () {\n              return _this21.triggerCycle(el, DEBOUNCE_TRIGGER);\n            }, timeout);\n          }\n        } else {\n          setTimeout(function () {\n            return _this21.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);\n          }, timeout);\n        }\n\n        if (el.form && this.once(el.form, \"bind-debounce\")) {\n          el.form.addEventListener(\"submit\", function (e) {\n            Array.from(new FormData(el.form).entries(), function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                  name = _ref8[0],\n                  val = _ref8[1];\n\n              var input = el.form.querySelector(\"[name=\\\"\".concat(name, \"\\\"]\"));\n\n              _this21.incCycle(input, DEBOUNCE_TRIGGER);\n\n              _this21.deletePrivate(input, THROTTLED);\n            });\n          });\n        }\n\n        if (this.once(el, \"bind-debounce\")) {\n          el.addEventListener(\"blur\", function (e) {\n            return _this21.triggerCycle(el, DEBOUNCE_TRIGGER);\n          });\n        }\n\n    }\n  },\n  triggerCycle: function triggerCycle(el, key, currentCycle) {\n    var _this$private = this[\"private\"](el, key),\n        _this$private2 = _slicedToArray(_this$private, 2),\n        cycle = _this$private2[0],\n        trigger = _this$private2[1];\n\n    if (!currentCycle) {\n      currentCycle = cycle;\n    }\n\n    if (currentCycle === cycle) {\n      this.incCycle(el, key);\n      trigger();\n    }\n  },\n  once: function once(el, key) {\n    if (this[\"private\"](el, key) === true) {\n      return false;\n    }\n\n    this.putPrivate(el, key, true);\n    return true;\n  },\n  incCycle: function incCycle(el, key) {\n    var trigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n    var _ref9 = this[\"private\"](el, key) || [0, trigger],\n        _ref10 = _slicedToArray(_ref9, 2),\n        currentCycle = _ref10[0],\n        oldTrigger = _ref10[1];\n\n    currentCycle++;\n    this.putPrivate(el, key, [currentCycle, trigger]);\n    return currentCycle;\n  },\n  discardError: function discardError(container, el, phxFeedbackFor) {\n    var field = el.getAttribute && el.getAttribute(phxFeedbackFor);\n    var input = field && container.querySelector(\"#\".concat(field));\n\n    if (!input) {\n      return;\n    }\n\n    if (!(this[\"private\"](input, PHX_HAS_FOCUSED) || this[\"private\"](input.form, PHX_HAS_SUBMITTED))) {\n      el.classList.add(PHX_NO_FEEDBACK_CLASS);\n    }\n  },\n  isPhxChild: function isPhxChild(node) {\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n  },\n  dispatchEvent: function dispatchEvent(target, eventString) {\n    var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var event = new CustomEvent(eventString, {\n      bubbles: true,\n      cancelable: true,\n      detail: detail\n    });\n    target.dispatchEvent(event);\n  },\n  cloneNode: function cloneNode(node, html) {\n    if (typeof html === \"undefined\") {\n      return node.cloneNode(true);\n    } else {\n      var cloned = node.cloneNode(false);\n      cloned.innerHTML = html;\n      return cloned;\n    }\n  },\n  mergeAttrs: function mergeAttrs(target, source) {\n    var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var sourceAttrs = source.attributes;\n\n    for (var i = sourceAttrs.length - 1; i >= 0; i--) {\n      var name = sourceAttrs[i].name;\n\n      if (exclude.indexOf(name) < 0) {\n        target.setAttribute(name, source.getAttribute(name));\n      }\n    }\n\n    var targetAttrs = target.attributes;\n\n    for (var _i3 = targetAttrs.length - 1; _i3 >= 0; _i3--) {\n      var _name = targetAttrs[_i3].name;\n\n      if (!source.hasAttribute(_name)) {\n        target.removeAttribute(_name);\n      }\n    }\n  },\n  mergeFocusedInput: function mergeFocusedInput(target, source) {\n    // skip selects because FF will reset highlighted index for any setAttribute\n    if (!(target instanceof HTMLSelectElement)) {\n      DOM.mergeAttrs(target, source, [\"value\"]);\n    }\n\n    if (source.readOnly) {\n      target.setAttribute(\"readonly\", true);\n    } else {\n      target.removeAttribute(\"readonly\");\n    }\n  },\n  hasSelectionRange: function hasSelectionRange(el) {\n    return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\n  },\n  restoreFocus: function restoreFocus(focused, selectionStart, selectionEnd) {\n    if (!DOM.isTextualInput(focused)) {\n      return;\n    }\n\n    var wasFocused = focused.matches(\":focus\");\n\n    if (focused.readOnly) {\n      focused.blur();\n    }\n\n    if (!wasFocused) {\n      focused.focus();\n    }\n\n    if (this.hasSelectionRange(focused)) {\n      focused.setSelectionRange(selectionStart, selectionEnd);\n    }\n  },\n  isFormInput: function isFormInput(el) {\n    return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\n  },\n  syncAttrsToProps: function syncAttrsToProps(el) {\n    if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\n      el.checked = el.getAttribute(\"checked\") !== null;\n    }\n  },\n  isTextualInput: function isTextualInput(el) {\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n  },\n  isNowTriggerFormExternal: function isNowTriggerFormExternal(el, phxTriggerExternal) {\n    return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;\n  },\n  syncPendingRef: function syncPendingRef(fromEl, toEl, disableWith) {\n    var ref = fromEl.getAttribute(PHX_REF);\n\n    if (ref === null) {\n      return true;\n    }\n\n    if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {\n      DOM.putPrivate(fromEl, PHX_REF, toEl);\n      return false;\n    } else {\n      PHX_EVENT_CLASSES.forEach(function (className) {\n        fromEl.classList.contains(className) && toEl.classList.add(className);\n      });\n      toEl.setAttribute(PHX_REF, ref);\n      return true;\n    }\n  },\n  cleanChildNodes: function cleanChildNodes(container, phxUpdate) {\n    if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\"])) {\n      var toRemove = [];\n      container.childNodes.forEach(function (childNode) {\n        if (!childNode.id) {\n          // Skip warning if it's an empty text node (e.g. a new-line)\n          var isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\n\n          if (!isEmptyTextNode) {\n            logError(\"only HTML element tags with an id are allowed inside containers with phx-update.\\n\\n\" + \"removing illegal node: \\\"\".concat((childNode.outerHTML || childNode.nodeValue).trim(), \"\\\"\\n\\n\"));\n          }\n\n          toRemove.push(childNode);\n        }\n      });\n      toRemove.forEach(function (childNode) {\n        return childNode.remove();\n      });\n    }\n  }\n};\n\nvar DOMPostMorphRestorer = /*#__PURE__*/function () {\n  function DOMPostMorphRestorer(containerBefore, containerAfter, updateType) {\n    _classCallCheck(this, DOMPostMorphRestorer);\n\n    var idsBefore = new Set();\n    var idsAfter = new Set(_toConsumableArray(containerAfter.children).map(function (child) {\n      return child.id;\n    }));\n    var elementsToModify = [];\n    Array.from(containerBefore.children).forEach(function (child) {\n      if (child.id) {\n        // all of our children should be elements with ids\n        idsBefore.add(child.id);\n\n        if (idsAfter.has(child.id)) {\n          var previousElementId = child.previousElementSibling && child.previousElementSibling.id;\n          elementsToModify.push({\n            elementId: child.id,\n            previousElementId: previousElementId\n          });\n        }\n      }\n    });\n    this.containerId = containerAfter.id;\n    this.updateType = updateType;\n    this.elementsToModify = elementsToModify;\n    this.elementIdsToAdd = _toConsumableArray(idsAfter).filter(function (id) {\n      return !idsBefore.has(id);\n    });\n  } // We do the following to optimize append/prepend operations:\n  //   1) Track ids of modified elements & of new elements\n  //   2) All the modified elements are put back in the correct position in the DOM tree\n  //      by storing the id of their previous sibling\n  //   3) New elements are going to be put in the right place by morphdom during append.\n  //      For prepend, we move them to the first position in the container\n\n\n  _createClass(DOMPostMorphRestorer, [{\n    key: \"perform\",\n    value: function perform() {\n      var container = DOM.byId(this.containerId);\n      this.elementsToModify.forEach(function (elementToModify) {\n        if (elementToModify.previousElementId) {\n          maybe(document.getElementById(elementToModify.previousElementId), function (previousElem) {\n            maybe(document.getElementById(elementToModify.elementId), function (elem) {\n              var isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\n\n              if (!isInRightPlace) {\n                previousElem.insertAdjacentElement(\"afterend\", elem);\n              }\n            });\n          });\n        } else {\n          // This is the first element in the container\n          maybe(document.getElementById(elementToModify.elementId), function (elem) {\n            var isInRightPlace = elem.previousElementSibling == null;\n\n            if (!isInRightPlace) {\n              container.insertAdjacentElement(\"afterbegin\", elem);\n            }\n          });\n        }\n      });\n\n      if (this.updateType == \"prepend\") {\n        this.elementIdsToAdd.reverse().forEach(function (elemId) {\n          maybe(document.getElementById(elemId), function (elem) {\n            return container.insertAdjacentElement(\"afterbegin\", elem);\n          });\n        });\n      }\n    }\n  }]);\n\n  return DOMPostMorphRestorer;\n}();\n\nvar DOMPatch = /*#__PURE__*/function () {\n  _createClass(DOMPatch, null, [{\n    key: \"patchEl\",\n    value: function patchEl(fromEl, toEl, activeElement) {\n      Object(morphdom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(fromEl, toEl, {\n        childrenOnly: false,\n        onBeforeElUpdated: function onBeforeElUpdated(fromEl, toEl) {\n          if (activeElement && activeElement.isSameNode(fromEl) && DOM.isFormInput(fromEl)) {\n            DOM.mergeFocusedInput(fromEl, toEl);\n            return false;\n          }\n        }\n      });\n    }\n  }]);\n\n  function DOMPatch(view, container, id, html, targetCID) {\n    _classCallCheck(this, DOMPatch);\n\n    this.view = view;\n    this.liveSocket = view.liveSocket;\n    this.container = container;\n    this.id = id;\n    this.rootID = view.root.id;\n    this.html = html;\n    this.targetCID = targetCID;\n    this.cidPatch = typeof this.targetCID === \"number\";\n    this.callbacks = {\n      beforeadded: [],\n      beforeupdated: [],\n      beforediscarded: [],\n      beforephxChildAdded: [],\n      afteradded: [],\n      afterupdated: [],\n      afterdiscarded: [],\n      afterphxChildAdded: []\n    };\n  }\n\n  _createClass(DOMPatch, [{\n    key: \"before\",\n    value: function before(kind, callback) {\n      this.callbacks[\"before\".concat(kind)].push(callback);\n    }\n  }, {\n    key: \"after\",\n    value: function after(kind, callback) {\n      this.callbacks[\"after\".concat(kind)].push(callback);\n    }\n  }, {\n    key: \"trackBefore\",\n    value: function trackBefore(kind) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.callbacks[\"before\".concat(kind)].forEach(function (callback) {\n        return callback.apply(void 0, args);\n      });\n    }\n  }, {\n    key: \"trackAfter\",\n    value: function trackAfter(kind) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this.callbacks[\"after\".concat(kind)].forEach(function (callback) {\n        return callback.apply(void 0, args);\n      });\n    }\n  }, {\n    key: \"markPrunableContentForRemoval\",\n    value: function markPrunableContentForRemoval() {\n      DOM.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", function (el) {\n        el.setAttribute(PHX_REMOVE, \"\");\n      });\n    }\n  }, {\n    key: \"perform\",\n    value: function perform() {\n      var _this22 = this;\n\n      var view = this.view,\n          liveSocket = this.liveSocket,\n          container = this.container,\n          html = this.html;\n      var targetContainer = this.isCIDPatch() ? this.targetCIDContainer() : container;\n\n      if (this.isCIDPatch() && !targetContainer) {\n        return;\n      }\n\n      var focused = liveSocket.getActiveElement();\n\n      var _ref11 = focused && DOM.hasSelectionRange(focused) ? focused : {},\n          selectionStart = _ref11.selectionStart,\n          selectionEnd = _ref11.selectionEnd;\n\n      var phxUpdate = liveSocket.binding(PHX_UPDATE);\n      var phxFeedbackFor = liveSocket.binding(PHX_FEEDBACK_FOR);\n      var disableWith = liveSocket.binding(PHX_DISABLE_WITH);\n      var phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n      var added = [];\n      var updates = [];\n      var appendPrependUpdates = [];\n      var diffHTML = liveSocket.time(\"premorph container prep\", function () {\n        return _this22.buildDiffHTML(container, html, phxUpdate, targetContainer);\n      });\n      this.trackBefore(\"added\", container);\n      this.trackBefore(\"updated\", container, container);\n      liveSocket.time(\"morphdom\", function () {\n        Object(morphdom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(targetContainer, diffHTML, {\n          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,\n          onBeforeNodeAdded: function onBeforeNodeAdded(el) {\n            //input handling\n            DOM.discardError(targetContainer, el, phxFeedbackFor);\n\n            _this22.trackBefore(\"added\", el);\n\n            return el;\n          },\n          onNodeAdded: function onNodeAdded(el) {\n            if (DOM.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              el.submit();\n            } // nested view handling\n\n\n            if (DOM.isPhxChild(el) && view.ownsElement(el)) {\n              _this22.trackAfter(\"phxChildAdded\", el);\n            }\n\n            added.push(el);\n          },\n          onNodeDiscarded: function onNodeDiscarded(el) {\n            // nested view handling\n            if (DOM.isPhxChild(el)) {\n              liveSocket.destroyViewByEl(el);\n            }\n\n            _this22.trackAfter(\"discarded\", el);\n          },\n          onBeforeNodeDiscarded: function onBeforeNodeDiscarded(el) {\n            if (el.getAttribute && el.getAttribute(PHX_REMOVE) !== null) {\n              return true;\n            }\n\n            if (el.parentNode !== null && DOM.isPhxUpdate(el.parentNode, phxUpdate, [\"append\", \"prepend\"]) && el.id) {\n              return false;\n            }\n\n            if (_this22.skipCIDSibling(el)) {\n              return false;\n            }\n\n            _this22.trackBefore(\"discarded\", el);\n\n            return true;\n          },\n          onElUpdated: function onElUpdated(el) {\n            if (DOM.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              el.submit();\n            }\n\n            updates.push(el);\n          },\n          onBeforeElUpdated: function onBeforeElUpdated(fromEl, toEl) {\n            DOM.cleanChildNodes(toEl, phxUpdate);\n\n            if (_this22.skipCIDSibling(toEl)) {\n              return false;\n            }\n\n            if (fromEl.getAttribute(phxUpdate) === \"ignore\") {\n              _this22.trackBefore(\"updated\", fromEl, toEl);\n\n              DOM.mergeAttrs(fromEl, toEl);\n              updates.push(fromEl);\n              return false;\n            }\n\n            if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n              return false;\n            }\n\n            if (!DOM.syncPendingRef(fromEl, toEl, disableWith)) {\n              return false;\n            } // nested view handling\n\n\n            if (DOM.isPhxChild(toEl)) {\n              var prevStatic = fromEl.getAttribute(PHX_STATIC);\n              DOM.mergeAttrs(fromEl, toEl);\n              fromEl.setAttribute(PHX_STATIC, prevStatic);\n              fromEl.setAttribute(PHX_ROOT_ID, _this22.rootID);\n              return false;\n            } // input handling\n\n\n            DOM.copyPrivates(toEl, fromEl);\n            DOM.discardError(targetContainer, toEl, phxFeedbackFor);\n            var isFocusedFormEl = focused && fromEl.isSameNode(focused) && DOM.isFormInput(fromEl);\n\n            if (isFocusedFormEl && !_this22.forceFocusedSelectUpdate(fromEl, toEl)) {\n              _this22.trackBefore(\"updated\", fromEl, toEl);\n\n              DOM.mergeFocusedInput(fromEl, toEl);\n              DOM.syncAttrsToProps(fromEl);\n              updates.push(fromEl);\n              return false;\n            } else {\n              if (DOM.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));\n              }\n\n              DOM.syncAttrsToProps(toEl);\n\n              _this22.trackBefore(\"updated\", fromEl, toEl);\n\n              return true;\n            }\n          }\n        });\n      });\n\n      if (liveSocket.isDebugEnabled()) {\n        detectDuplicateIds();\n      }\n\n      if (appendPrependUpdates.length > 0) {\n        liveSocket.time(\"post-morph append/prepend restoration\", function () {\n          appendPrependUpdates.forEach(function (update) {\n            return update.perform();\n          });\n        });\n      }\n\n      liveSocket.silenceEvents(function () {\n        return DOM.restoreFocus(focused, selectionStart, selectionEnd);\n      });\n      DOM.dispatchEvent(document, \"phx:update\");\n      added.forEach(function (el) {\n        return _this22.trackAfter(\"added\", el);\n      });\n      updates.forEach(function (el) {\n        return _this22.trackAfter(\"updated\", el);\n      });\n      return true;\n    }\n  }, {\n    key: \"forceFocusedSelectUpdate\",\n    value: function forceFocusedSelectUpdate(fromEl, toEl) {\n      return fromEl.multiple === true || fromEl.innerHTML != toEl.innerHTML;\n    }\n  }, {\n    key: \"isCIDPatch\",\n    value: function isCIDPatch() {\n      return this.cidPatch;\n    }\n  }, {\n    key: \"skipCIDSibling\",\n    value: function skipCIDSibling(el) {\n      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;\n    }\n  }, {\n    key: \"targetCIDContainer\",\n    value: function targetCIDContainer() {\n      if (!this.isCIDPatch()) {\n        return;\n      }\n\n      var _DOM$findComponentNod = DOM.findComponentNodeList(this.container, this.targetCID),\n          _DOM$findComponentNod2 = _toArray(_DOM$findComponentNod),\n          first = _DOM$findComponentNod2[0],\n          rest = _DOM$findComponentNod2.slice(1);\n\n      if (rest.length === 0) {\n        return first;\n      } else {\n        return first && first.parentNode;\n      }\n    } // builds HTML for morphdom patch\n    // - for full patches of LiveView or a component with a single\n    //   root node, simply returns the HTML\n    // - for patches of a component with multiple root nodes, the\n    //   parent node becomes the target container and non-component\n    //   siblings are marked as skip.\n\n  }, {\n    key: \"buildDiffHTML\",\n    value: function buildDiffHTML(container, html, phxUpdate, targetContainer) {\n      var _this23 = this;\n\n      var isCIDPatch = this.isCIDPatch();\n      var isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();\n\n      if (!isCIDPatch || isCIDWithSingleRoot) {\n        return html;\n      } else {\n        // component patch with multiple CID roots\n        var diffContainer = null;\n        var template = document.createElement(\"template\");\n        diffContainer = DOM.cloneNode(targetContainer);\n\n        var _DOM$findComponentNod3 = DOM.findComponentNodeList(diffContainer, this.targetCID),\n            _DOM$findComponentNod4 = _toArray(_DOM$findComponentNod3),\n            firstComponent = _DOM$findComponentNod4[0],\n            rest = _DOM$findComponentNod4.slice(1);\n\n        template.innerHTML = html;\n        rest.forEach(function (el) {\n          return el.remove();\n        });\n        Array.from(diffContainer.childNodes).forEach(function (child) {\n          // we can only skip trackable nodes with an ID\n          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== _this23.targetCID.toString()) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n        });\n        Array.from(template.content.childNodes).forEach(function (el) {\n          return diffContainer.insertBefore(el, firstComponent);\n        });\n        firstComponent.remove();\n        return diffContainer.outerHTML;\n      }\n    }\n  }]);\n\n  return DOMPatch;\n}();\n\nvar View = /*#__PURE__*/function () {\n  function View(el, liveSocket, parentView, href, flash) {\n    var _this24 = this;\n\n    _classCallCheck(this, View);\n\n    this.liveSocket = liveSocket;\n    this.flash = flash;\n    this.parent = parentView;\n    this.root = parentView ? parentView.root : this;\n    this.el = el;\n    this.id = this.el.id;\n    this.view = this.el.getAttribute(PHX_VIEW);\n    this.ref = 0;\n    this.childJoins = 0;\n    this.loaderTimer = null;\n    this.pendingDiffs = [];\n    this.href = href;\n    this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n    this.joinPending = true;\n    this.destroyed = false;\n\n    this.joinCallback = function () {};\n\n    this.stopCallback = function () {};\n\n    this.pendingJoinOps = this.parent ? null : [];\n    this.viewHooks = {};\n    this.children = this.parent ? null : {};\n    this.root.children[this.id] = {};\n    this.channel = this.liveSocket.channel(\"lv:\".concat(this.id), function () {\n      return {\n        url: _this24.href,\n        params: _this24.connectParams(),\n        session: _this24.getSession(),\n        \"static\": _this24.getStatic(),\n        flash: _this24.flash\n      };\n    });\n    this.showLoader(this.liveSocket.loaderTimeout);\n    this.bindChannel();\n  }\n\n  _createClass(View, [{\n    key: \"isMain\",\n    value: function isMain() {\n      return this.liveSocket.main === this;\n    }\n  }, {\n    key: \"connectParams\",\n    value: function connectParams() {\n      var params = this.liveSocket.params(this.view);\n      var manifest = DOM.all(document, \"[\".concat(this.binding(PHX_TRACK_STATIC), \"]\")).map(function (node) {\n        return node.src || node.href;\n      }).filter(function (url) {\n        return typeof url === \"string\";\n      });\n\n      if (manifest.length > 0) {\n        params[\"_track_static\"] = manifest;\n      }\n\n      params[\"_mounts\"] = this.joinCount;\n      return params;\n    }\n  }, {\n    key: \"name\",\n    value: function name() {\n      return this.view;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.channel.canPush();\n    }\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return this.el.getAttribute(PHX_SESSION);\n    }\n  }, {\n    key: \"getStatic\",\n    value: function getStatic() {\n      var val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this25 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      this.destroyAllChildren();\n      this.destroyed = true;\n      delete this.root.children[this.id];\n\n      if (this.parent) {\n        delete this.root.children[this.parent.id][this.id];\n      }\n\n      clearTimeout(this.loaderTimer);\n\n      var onFinished = function onFinished() {\n        callback();\n\n        for (var id in _this25.viewHooks) {\n          _this25.viewHooks[id].__trigger__(\"beforeDestroy\");\n\n          _this25.destroyHook(_this25.viewHooks[id]);\n        }\n      };\n\n      this.log(\"destroyed\", function () {\n        return [\"the child has been removed from the parent\"];\n      });\n      this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n    }\n  }, {\n    key: \"setContainerClasses\",\n    value: function setContainerClasses() {\n      var _this$el$classList;\n\n      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n\n      (_this$el$classList = this.el.classList).add.apply(_this$el$classList, arguments);\n    }\n  }, {\n    key: \"isLoading\",\n    value: function isLoading() {\n      return this.el.classList.contains(PHX_DISCONNECTED_CLASS);\n    }\n  }, {\n    key: \"showLoader\",\n    value: function showLoader(timeout) {\n      var _this26 = this;\n\n      clearTimeout(this.loaderTimer);\n\n      if (timeout) {\n        this.loaderTimer = setTimeout(function () {\n          return _this26.showLoader();\n        }, timeout);\n      } else {\n        for (var id in this.viewHooks) {\n          this.viewHooks[id].__trigger__(\"disconnected\");\n        }\n\n        this.setContainerClasses(PHX_DISCONNECTED_CLASS);\n      }\n    }\n  }, {\n    key: \"hideLoader\",\n    value: function hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.setContainerClasses(PHX_CONNECTED_CLASS);\n    }\n  }, {\n    key: \"triggerReconnected\",\n    value: function triggerReconnected() {\n      for (var id in this.viewHooks) {\n        this.viewHooks[id].__trigger__(\"reconnected\");\n      }\n    }\n  }, {\n    key: \"log\",\n    value: function log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n  }, {\n    key: \"withinTargets\",\n    value: function withinTargets(phxTarget, callback) {\n      var _this27 = this;\n\n      if (/^(0|[1-9]\\d*)$/.test(phxTarget)) {\n        var targets = DOM.findComponentNodeList(this.el, phxTarget);\n\n        if (targets.length === 0) {\n          logError(\"no component found matching phx-target of \".concat(phxTarget));\n        } else {\n          callback(this, targets[0]);\n        }\n      } else {\n        var _targets = Array.from(document.querySelectorAll(phxTarget));\n\n        if (_targets.length === 0) {\n          logError(\"nothing found matching the phx-target selector \\\"\".concat(phxTarget, \"\\\"\"));\n        }\n\n        _targets.forEach(function (target) {\n          return _this27.liveSocket.owner(target, function (view) {\n            return callback(view, target);\n          });\n        });\n      }\n    }\n  }, {\n    key: \"applyDiff\",\n    value: function applyDiff(type, rawDiff, callback) {\n      this.log(type, function () {\n        return [\"\", clone(rawDiff)];\n      });\n\n      var _Rendered$extract = Rendered.extract(rawDiff),\n          diff = _Rendered$extract.diff,\n          reply = _Rendered$extract.reply,\n          events = _Rendered$extract.events,\n          title = _Rendered$extract.title;\n\n      if (title) {\n        DOM.putTitle(title);\n      }\n\n      callback({\n        diff: diff,\n        reply: reply,\n        events: events\n      });\n      return reply;\n    }\n  }, {\n    key: \"onJoin\",\n    value: function onJoin(resp) {\n      var _this28 = this;\n\n      var rendered = resp.rendered;\n      this.joinCount++;\n      this.childJoins = 0;\n      this.joinPending = true;\n      this.flash = null;\n      Browser.dropLocal(this.name(), CONSECUTIVE_RELOADS);\n      this.applyDiff(\"mount\", rendered, function (_ref12) {\n        var diff = _ref12.diff,\n            events = _ref12.events;\n        _this28.rendered = new Rendered(_this28.id, diff);\n\n        var html = _this28.renderContainer(null, \"join\");\n\n        _this28.dropPendingRefs();\n\n        var forms = _this28.formsForRecovery(html);\n\n        if (_this28.joinCount > 1 && forms.length > 0) {\n          forms.forEach(function (form, i) {\n            _this28.pushFormRecovery(form, function (resp) {\n              if (i === forms.length - 1) {\n                _this28.onJoinComplete(resp, html, events);\n              }\n            });\n          });\n        } else {\n          _this28.onJoinComplete(resp, html, events);\n        }\n      });\n    }\n  }, {\n    key: \"dropPendingRefs\",\n    value: function dropPendingRefs() {\n      DOM.all(this.el, \"[\".concat(PHX_REF, \"]\"), function (el) {\n        return el.removeAttribute(PHX_REF);\n      });\n    }\n  }, {\n    key: \"onJoinComplete\",\n    value: function onJoinComplete(_ref13, html, events) {\n      var _this29 = this;\n\n      var live_patch = _ref13.live_patch;\n\n      // In order to provide a better experience, we want to join\n      // all LiveViews first and only then apply their patches.\n      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\n        return this.applyJoinPatch(live_patch, html, events);\n      } // One downside of this approach is that we need to find phxChildren\n      // in the html fragment, instead of directly on the DOM. The fragment\n      // also does not include PHX_STATIC, so we need to copy it over from\n      // the DOM.\n\n\n      var newChildren = DOM.findPhxChildrenInFragment(html, this.id).filter(function (toEl) {\n        var fromEl = toEl.id && _this29.el.querySelector(\"#\".concat(toEl.id));\n\n        var phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n\n        return _this29.joinChild(toEl);\n      });\n\n      if (newChildren.length === 0) {\n        if (this.parent) {\n          this.root.pendingJoinOps.push([this, function () {\n            return _this29.applyJoinPatch(live_patch, html, events);\n          }]);\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n          this.applyJoinPatch(live_patch, html, events);\n        }\n      } else {\n        this.root.pendingJoinOps.push([this, function () {\n          return _this29.applyJoinPatch(live_patch, html, events);\n        }]);\n      }\n    }\n  }, {\n    key: \"attachTrueDocEl\",\n    value: function attachTrueDocEl() {\n      this.el = DOM.byId(this.id);\n      this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n    }\n  }, {\n    key: \"dispatchEvents\",\n    value: function dispatchEvents(events) {\n      events.forEach(function (_ref14) {\n        var _ref15 = _slicedToArray(_ref14, 2),\n            event = _ref15[0],\n            payload = _ref15[1];\n\n        window.dispatchEvent(new CustomEvent(\"phx:hook:\".concat(event), {\n          detail: payload\n        }));\n      });\n    }\n  }, {\n    key: \"applyJoinPatch\",\n    value: function applyJoinPatch(live_patch, html, events) {\n      var _this30 = this;\n\n      this.attachTrueDocEl();\n      var patch = new DOMPatch(this, this.el, this.id, html, null);\n      patch.markPrunableContentForRemoval();\n      this.performPatch(patch, false);\n      this.joinNewChildren();\n      DOM.all(this.el, \"[\".concat(this.binding(PHX_HOOK), \"]\"), function (hookEl) {\n        var hook = _this30.addHook(hookEl);\n\n        if (hook) {\n          hook.__trigger__(\"mounted\");\n        }\n      });\n      this.joinPending = false;\n      this.dispatchEvents(events);\n      this.applyPendingUpdates();\n\n      if (live_patch) {\n        var kind = live_patch.kind,\n            to = live_patch.to;\n        this.liveSocket.historyPatch(to, kind);\n      }\n\n      this.hideLoader();\n\n      if (this.joinCount > 1) {\n        this.triggerReconnected();\n      }\n\n      this.stopCallback();\n    }\n  }, {\n    key: \"triggerBeforeUpdateHook\",\n    value: function triggerBeforeUpdateHook(fromEl, toEl) {\n      this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n      var hook = this.getHook(fromEl);\n      var isIgnored = hook && fromEl.getAttribute(this.binding(PHX_UPDATE)) === \"ignore\";\n\n      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\n        hook.__trigger__(\"beforeUpdate\");\n\n        return hook;\n      }\n    }\n  }, {\n    key: \"triggerUpdatedHook\",\n    value: function triggerUpdatedHook(hook) {\n      hook.__trigger__(\"updated\");\n    }\n  }, {\n    key: \"performPatch\",\n    value: function performPatch(patch, pruneCids) {\n      var _this31 = this;\n\n      var destroyedCIDs = [];\n      var phxChildrenAdded = false;\n      var updatedHookIds = new Set();\n      patch.after(\"added\", function (el) {\n        var newHook = _this31.addHook(el);\n\n        if (newHook) {\n          newHook.__trigger__(\"mounted\");\n        }\n      });\n      patch.after(\"phxChildAdded\", function (el) {\n        return phxChildrenAdded = true;\n      });\n      patch.before(\"updated\", function (fromEl, toEl) {\n        var hook = _this31.triggerBeforeUpdateHook(fromEl, toEl);\n\n        if (hook) {\n          updatedHookIds.add(fromEl.id);\n        }\n      });\n      patch.after(\"updated\", function (el) {\n        if (updatedHookIds.has(el.id)) {\n          _this31.triggerUpdatedHook(_this31.getHook(el));\n        }\n      });\n      patch.before(\"discarded\", function (el) {\n        var hook = _this31.getHook(el);\n\n        if (hook) {\n          hook.__trigger__(\"beforeDestroy\");\n        }\n      });\n      patch.after(\"discarded\", function (el) {\n        var cid = _this31.componentID(el);\n\n        if (typeof cid === \"number\" && destroyedCIDs.indexOf(cid) === -1) {\n          destroyedCIDs.push(cid);\n        }\n\n        var hook = _this31.getHook(el);\n\n        hook && _this31.destroyHook(hook);\n      });\n      patch.perform(); // We should not pruneCids on joins. Otherwise, in case of\n      // rejoins, we may notify cids that no longer belong to the\n      // current LiveView to be removed.\n\n      if (pruneCids) {\n        this.maybePushComponentsDestroyed(destroyedCIDs);\n      }\n\n      return phxChildrenAdded;\n    }\n  }, {\n    key: \"joinNewChildren\",\n    value: function joinNewChildren() {\n      var _this32 = this;\n\n      DOM.findPhxChildren(this.el, this.id).forEach(function (el) {\n        return _this32.joinChild(el);\n      });\n    }\n  }, {\n    key: \"getChildById\",\n    value: function getChildById(id) {\n      return this.root.children[this.id][id];\n    }\n  }, {\n    key: \"getDescendentByEl\",\n    value: function getDescendentByEl(el) {\n      if (el.id === this.id) {\n        return this;\n      } else {\n        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];\n      }\n    }\n  }, {\n    key: \"destroyDescendent\",\n    value: function destroyDescendent(id) {\n      for (var parentId in this.root.children) {\n        for (var childId in this.root.children[parentId]) {\n          if (childId === id) {\n            return this.root.children[parentId][childId].destroy();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"joinChild\",\n    value: function joinChild(el) {\n      var child = this.getChildById(el.id);\n\n      if (!child) {\n        var view = new View(el, this.liveSocket, this);\n        this.root.children[this.id][view.id] = view;\n        view.join();\n        this.childJoins++;\n        return true;\n      }\n    }\n  }, {\n    key: \"isJoinPending\",\n    value: function isJoinPending() {\n      return this.joinPending;\n    }\n  }, {\n    key: \"ackJoin\",\n    value: function ackJoin(child) {\n      this.childJoins--;\n\n      if (this.childJoins === 0) {\n        if (this.parent) {\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n        }\n      }\n    }\n  }, {\n    key: \"onAllChildJoinsComplete\",\n    value: function onAllChildJoinsComplete() {\n      this.joinCallback();\n      this.pendingJoinOps.forEach(function (_ref16) {\n        var _ref17 = _slicedToArray(_ref16, 2),\n            view = _ref17[0],\n            op = _ref17[1];\n\n        if (!view.isDestroyed()) {\n          op();\n        }\n      });\n      this.pendingJoinOps = [];\n    }\n  }, {\n    key: \"update\",\n    value: function update(diff, events) {\n      var _this33 = this;\n\n      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {\n        return this.pendingDiffs.push({\n          diff: diff,\n          events: events\n        });\n      }\n\n      this.rendered.mergeDiff(diff);\n      var phxChildrenAdded = false; // When the diff only contains component diffs, then walk components\n      // and patch only the parent component containers found in the diff.\n      // Otherwise, patch entire LV container.\n\n      if (this.rendered.isComponentOnlyDiff(diff)) {\n        this.liveSocket.time(\"component patch complete\", function () {\n          var parentCids = DOM.findParentCIDs(_this33.el, _this33.rendered.componentCIDs(diff));\n          parentCids.forEach(function (parentCID) {\n            if (_this33.componentPatch(_this33.rendered.getComponent(diff, parentCID), parentCID)) {\n              phxChildrenAdded = true;\n            }\n          });\n        });\n      } else if (!isEmpty(diff)) {\n        this.liveSocket.time(\"full patch complete\", function () {\n          var html = _this33.renderContainer(diff, \"update\");\n\n          var patch = new DOMPatch(_this33, _this33.el, _this33.id, html, null);\n          phxChildrenAdded = _this33.performPatch(patch, true);\n        });\n      }\n\n      this.dispatchEvents(events);\n\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n  }, {\n    key: \"renderContainer\",\n    value: function renderContainer(diff, kind) {\n      var _this34 = this;\n\n      return this.liveSocket.time(\"toString diff (\".concat(kind, \")\"), function () {\n        var tag = _this34.el.tagName;\n        var cids = diff ? _this34.rendered.componentCIDs(diff) : null;\n\n        var html = _this34.rendered.toString(cids);\n\n        return \"<\".concat(tag, \">\").concat(html, \"</\").concat(tag, \">\");\n      });\n    }\n  }, {\n    key: \"componentPatch\",\n    value: function componentPatch(diff, cid) {\n      if (isEmpty(diff)) return false;\n      var html = this.rendered.componentToString(cid);\n      var patch = new DOMPatch(this, this.el, this.id, html, cid);\n      var childrenAdded = this.performPatch(patch, true);\n      return childrenAdded;\n    }\n  }, {\n    key: \"getHook\",\n    value: function getHook(el) {\n      return this.viewHooks[ViewHook.elementID(el)];\n    }\n  }, {\n    key: \"addHook\",\n    value: function addHook(el) {\n      if (ViewHook.elementID(el) || !el.getAttribute) {\n        return;\n      }\n\n      var hookName = el.getAttribute(this.binding(PHX_HOOK));\n\n      if (hookName && !this.ownsElement(el)) {\n        return;\n      }\n\n      var callbacks = this.liveSocket.getHookCallbacks(hookName);\n\n      if (callbacks) {\n        if (!el.id) {\n          logError(\"no DOM ID for hook \\\"\".concat(hookName, \"\\\". Hooks require a unique ID on each element.\"), el);\n        }\n\n        var hook = new ViewHook(this, el, callbacks);\n        this.viewHooks[ViewHook.elementID(hook.el)] = hook;\n        return hook;\n      } else if (hookName !== null) {\n        logError(\"unknown hook found for \\\"\".concat(hookName, \"\\\"\"), el);\n      }\n    }\n  }, {\n    key: \"destroyHook\",\n    value: function destroyHook(hook) {\n      hook.__trigger__(\"destroyed\");\n\n      hook.__cleanup__();\n\n      delete this.viewHooks[ViewHook.elementID(hook.el)];\n    }\n  }, {\n    key: \"applyPendingUpdates\",\n    value: function applyPendingUpdates() {\n      var _this35 = this;\n\n      this.pendingDiffs.forEach(function (_ref18) {\n        var diff = _ref18.diff,\n            events = _ref18.events;\n        return _this35.update(diff, events);\n      });\n      this.pendingDiffs = [];\n    }\n  }, {\n    key: \"onChannel\",\n    value: function onChannel(event, cb) {\n      var _this36 = this;\n\n      this.liveSocket.onChannel(this.channel, event, function (resp) {\n        if (_this36.isJoinPending()) {\n          _this36.root.pendingJoinOps.push([_this36, function () {\n            return cb(resp);\n          }]);\n        } else {\n          cb(resp);\n        }\n      });\n    }\n  }, {\n    key: \"bindChannel\",\n    value: function bindChannel() {\n      var _this37 = this;\n\n      // The diff event should be handled by the regular update operations.\n      // All other operations are queued to be applied only after join.\n      this.liveSocket.onChannel(this.channel, \"diff\", function (rawDiff) {\n        _this37.applyDiff(\"update\", rawDiff, function (_ref19) {\n          var diff = _ref19.diff,\n              events = _ref19.events;\n          return _this37.update(diff, events);\n        });\n      });\n      this.onChannel(\"redirect\", function (_ref20) {\n        var to = _ref20.to,\n            flash = _ref20.flash;\n        return _this37.onRedirect({\n          to: to,\n          flash: flash\n        });\n      });\n      this.onChannel(\"live_patch\", function (redir) {\n        return _this37.onLivePatch(redir);\n      });\n      this.onChannel(\"live_redirect\", function (redir) {\n        return _this37.onLiveRedirect(redir);\n      });\n      this.channel.onError(function (reason) {\n        return _this37.onError(reason);\n      });\n      this.channel.onClose(function () {\n        return _this37.onClose();\n      });\n    }\n  }, {\n    key: \"destroyAllChildren\",\n    value: function destroyAllChildren() {\n      for (var id in this.root.children[this.id]) {\n        this.getChildById(id).destroy();\n      }\n    }\n  }, {\n    key: \"onLiveRedirect\",\n    value: function onLiveRedirect(redir) {\n      var to = redir.to,\n          kind = redir.kind,\n          flash = redir.flash;\n      var url = this.expandURL(to);\n      this.liveSocket.historyRedirect(url, kind, flash);\n    }\n  }, {\n    key: \"onLivePatch\",\n    value: function onLivePatch(redir) {\n      var to = redir.to,\n          kind = redir.kind;\n      this.href = this.expandURL(to);\n      this.liveSocket.historyPatch(to, kind);\n    }\n  }, {\n    key: \"expandURL\",\n    value: function expandURL(to) {\n      return to.startsWith(\"/\") ? \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(to) : to;\n    }\n  }, {\n    key: \"onRedirect\",\n    value: function onRedirect(_ref21) {\n      var to = _ref21.to,\n          flash = _ref21.flash;\n      this.liveSocket.redirect(to, flash);\n    }\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this.destroyed;\n    }\n  }, {\n    key: \"join\",\n    value: function join(callback) {\n      var _this38 = this;\n\n      if (!this.parent) {\n        this.stopCallback = this.liveSocket.withPageLoading({\n          to: this.href,\n          kind: \"initial\"\n        });\n      }\n\n      this.joinCallback = function () {\n        return callback && callback(_this38, _this38.joinCount);\n      };\n\n      this.liveSocket.wrapPush(function () {\n        return _this38.channel.join().receive(\"ok\", function (data) {\n          return _this38.onJoin(data);\n        }).receive(\"error\", function (resp) {\n          return _this38.onJoinError(resp);\n        }).receive(\"timeout\", function () {\n          return _this38.onJoinError({\n            reason: \"timeout\"\n          });\n        });\n      });\n    }\n  }, {\n    key: \"onJoinError\",\n    value: function onJoinError(resp) {\n      if (resp.redirect || resp.live_redirect) {\n        this.joinPending = false;\n        this.channel.leave();\n      }\n\n      if (resp.redirect) {\n        return this.onRedirect(resp.redirect);\n      }\n\n      if (resp.live_redirect) {\n        return this.onLiveRedirect(resp.live_redirect);\n      }\n\n      this.log(\"error\", function () {\n        return [\"unable to join\", resp];\n      });\n      return this.liveSocket.reloadWithJitter(this);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {\n        return this.liveSocket.reloadWithJitter(this);\n      }\n\n      this.destroyAllChildren();\n      this.liveSocket.dropActiveElement(this); // document.activeElement can be null in Internet Explorer 11\n\n      if (document.activeElement) {\n        document.activeElement.blur();\n      }\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(reason) {\n      this.onClose();\n      this.log(\"error\", function () {\n        return [\"view crashed\", reason];\n      });\n\n      if (!this.liveSocket.isUnloaded()) {\n        this.displayError();\n      }\n    }\n  }, {\n    key: \"displayError\",\n    value: function displayError() {\n      if (this.isMain()) {\n        DOM.dispatchEvent(window, \"phx:page-loading-start\", {\n          to: this.href,\n          kind: \"error\"\n        });\n      }\n\n      this.showLoader();\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n    }\n  }, {\n    key: \"pushWithReply\",\n    value: function pushWithReply(refGenerator, event, payload) {\n      var _this39 = this;\n\n      var onReply = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n      var _ref22 = refGenerator ? refGenerator() : [null, []],\n          _ref23 = _slicedToArray(_ref22, 2),\n          ref = _ref23[0],\n          _ref23$ = _slicedToArray(_ref23[1], 1),\n          el = _ref23$[0];\n\n      var onLoadingDone = function onLoadingDone() {};\n\n      if (el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {\n        onLoadingDone = this.liveSocket.withPageLoading({\n          kind: \"element\",\n          target: el\n        });\n      }\n\n      if (typeof payload.cid !== \"number\") {\n        delete payload.cid;\n      }\n\n      return this.liveSocket.wrapPush(function () {\n        return _this39.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", function (resp) {\n          var hookReply = null;\n\n          if (ref !== null) {\n            _this39.undoRefs(ref);\n          }\n\n          if (resp.diff) {\n            hookReply = _this39.applyDiff(\"update\", resp.diff, function (_ref24) {\n              var diff = _ref24.diff,\n                  events = _ref24.events;\n\n              _this39.update(diff, events);\n            });\n          }\n\n          if (resp.redirect) {\n            _this39.onRedirect(resp.redirect);\n          }\n\n          if (resp.live_patch) {\n            _this39.onLivePatch(resp.live_patch);\n          }\n\n          if (resp.live_redirect) {\n            _this39.onLiveRedirect(resp.live_redirect);\n          }\n\n          onLoadingDone();\n          onReply(resp, hookReply);\n        });\n      });\n    }\n  }, {\n    key: \"undoRefs\",\n    value: function undoRefs(ref) {\n      var _this40 = this;\n\n      DOM.all(this.el, \"[\".concat(PHX_REF, \"=\\\"\").concat(ref, \"\\\"]\"), function (el) {\n        // remove refs\n        el.removeAttribute(PHX_REF); // restore inputs\n\n        if (el.getAttribute(PHX_READONLY) !== null) {\n          el.readOnly = false;\n          el.removeAttribute(PHX_READONLY);\n        }\n\n        if (el.getAttribute(PHX_DISABLED) !== null) {\n          el.disabled = false;\n          el.removeAttribute(PHX_DISABLED);\n        } // remove classes\n\n\n        PHX_EVENT_CLASSES.forEach(function (className) {\n          return DOM.removeClass(el, className);\n        }); // restore disables\n\n        var disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n\n        if (disableRestore !== null) {\n          el.innerText = disableRestore;\n          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n        }\n\n        var toEl = DOM[\"private\"](el, PHX_REF);\n\n        if (toEl) {\n          var hook = _this40.triggerBeforeUpdateHook(el, toEl);\n\n          DOMPatch.patchEl(el, toEl, _this40.liveSocket.getActiveElement());\n\n          if (hook) {\n            _this40.triggerUpdatedHook(hook);\n          }\n\n          DOM.deletePrivate(el, PHX_REF);\n        }\n      });\n    }\n  }, {\n    key: \"putRef\",\n    value: function putRef(elements, event) {\n      var newRef = this.ref++;\n      var disableWith = this.binding(PHX_DISABLE_WITH);\n      elements.forEach(function (el) {\n        el.classList.add(\"phx-\".concat(event, \"-loading\"));\n        el.setAttribute(PHX_REF, newRef);\n        var disableText = el.getAttribute(disableWith);\n\n        if (disableText !== null) {\n          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n          }\n\n          el.innerText = disableText;\n        }\n      });\n      return [newRef, elements];\n    }\n  }, {\n    key: \"componentID\",\n    value: function componentID(el) {\n      var cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n      return cid ? parseInt(cid) : null;\n    }\n  }, {\n    key: \"targetComponentID\",\n    value: function targetComponentID(target, targetCtx) {\n      if (target.getAttribute(this.binding(\"target\"))) {\n        return this.closestComponentID(targetCtx);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"closestComponentID\",\n    value: function closestComponentID(targetCtx) {\n      var _this41 = this;\n\n      if (targetCtx) {\n        return maybe(targetCtx.closest(\"[\".concat(PHX_COMPONENT, \"]\")), function (el) {\n          return _this41.ownsElement(el) && _this41.componentID(el);\n        });\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"pushHookEvent\",\n    value: function pushHookEvent(targetCtx, event, payload, onReply) {\n      var _this$putRef = this.putRef([], \"hook\"),\n          _this$putRef2 = _slicedToArray(_this$putRef, 2),\n          ref = _this$putRef2[0],\n          els = _this$putRef2[1];\n\n      this.pushWithReply(function () {\n        return [ref, els];\n      }, \"event\", {\n        type: \"hook\",\n        event: event,\n        value: payload,\n        cid: this.closestComponentID(targetCtx)\n      }, function (resp, reply) {\n        return onReply(reply, ref);\n      });\n      return ref;\n    }\n  }, {\n    key: \"extractMeta\",\n    value: function extractMeta(el, meta) {\n      var prefix = this.binding(\"value-\");\n\n      for (var i = 0; i < el.attributes.length; i++) {\n        var name = el.attributes[i].name;\n\n        if (name.startsWith(prefix)) {\n          meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n        }\n      }\n\n      if (el.value !== undefined) {\n        meta.value = el.value;\n\n        if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\n          delete meta.value;\n        }\n      }\n\n      return meta;\n    }\n  }, {\n    key: \"pushEvent\",\n    value: function pushEvent(type, el, targetCtx, phxEvent, meta) {\n      var _this42 = this;\n\n      this.pushWithReply(function () {\n        return _this42.putRef([el], type);\n      }, \"event\", {\n        type: type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta),\n        cid: this.targetComponentID(el, targetCtx)\n      });\n    }\n  }, {\n    key: \"pushKey\",\n    value: function pushKey(keyElement, targetCtx, kind, phxEvent, meta) {\n      var _this43 = this;\n\n      this.pushWithReply(function () {\n        return _this43.putRef([keyElement], kind);\n      }, \"event\", {\n        type: kind,\n        event: phxEvent,\n        value: this.extractMeta(keyElement, meta),\n        cid: this.targetComponentID(keyElement, targetCtx)\n      });\n    }\n  }, {\n    key: \"pushInput\",\n    value: function pushInput(inputEl, targetCtx, phxEvent, eventTarget, callback) {\n      var _this44 = this;\n\n      this.pushWithReply(function () {\n        return _this44.putRef([inputEl, inputEl.form], \"change\");\n      }, \"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: serializeForm(inputEl.form, {\n          _target: eventTarget.name\n        }),\n        cid: this.targetComponentID(inputEl.form, targetCtx)\n      }, callback);\n    }\n  }, {\n    key: \"pushFormSubmit\",\n    value: function pushFormSubmit(formEl, targetCtx, phxEvent, onReply) {\n      var _this45 = this;\n\n      var filterIgnored = function filterIgnored(el) {\n        return !closestPhxBinding(el, \"\".concat(_this45.binding(PHX_UPDATE), \"=ignore\"), el.form);\n      };\n\n      var refGenerator = function refGenerator() {\n        var disables = DOM.all(formEl, \"[\".concat(_this45.binding(PHX_DISABLE_WITH), \"]\"));\n        var buttons = DOM.all(formEl, \"button\").filter(filterIgnored);\n        var inputs = DOM.all(formEl, \"input,textarea,select\").filter(filterIgnored);\n        buttons.forEach(function (button) {\n          button.setAttribute(PHX_DISABLED, button.disabled);\n          button.disabled = true;\n        });\n        inputs.forEach(function (input) {\n          input.setAttribute(PHX_READONLY, input.readOnly);\n          input.readOnly = true;\n        });\n        formEl.setAttribute(_this45.binding(PHX_PAGE_LOADING), \"\");\n        return _this45.putRef([formEl].concat(disables).concat(buttons).concat(inputs), \"submit\");\n      };\n\n      this.pushWithReply(refGenerator, \"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: serializeForm(formEl),\n        cid: this.targetComponentID(formEl, targetCtx)\n      }, onReply);\n    }\n  }, {\n    key: \"pushFormRecovery\",\n    value: function pushFormRecovery(form, callback) {\n      var _this46 = this;\n\n      this.liveSocket.withinOwners(form, function (view, targetCtx) {\n        var input = form.elements[0];\n        var phxEvent = form.getAttribute(_this46.binding(PHX_AUTO_RECOVER)) || form.getAttribute(_this46.binding(\"change\"));\n        view.pushInput(input, targetCtx, phxEvent, input, callback);\n      });\n    }\n  }, {\n    key: \"pushLinkPatch\",\n    value: function pushLinkPatch(href, targetEl, callback) {\n      var _this47 = this;\n\n      var linkRef = this.liveSocket.setPendingLink(href);\n      var refGen = targetEl ? function () {\n        return _this47.putRef([targetEl], \"click\");\n      } : null;\n      this.pushWithReply(refGen, \"link\", {\n        url: href\n      }, function (resp) {\n        if (resp.link_redirect) {\n          _this47.liveSocket.replaceMain(href, null, callback, linkRef);\n        } else if (_this47.liveSocket.commitPendingLink(linkRef)) {\n          _this47.href = href;\n\n          _this47.applyPendingUpdates();\n\n          callback && callback();\n        }\n      }).receive(\"timeout\", function () {\n        return _this47.liveSocket.redirect(window.location.href);\n      });\n    }\n  }, {\n    key: \"formsForRecovery\",\n    value: function formsForRecovery(html) {\n      var _this48 = this;\n\n      var phxChange = this.binding(\"change\");\n      var template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return DOM.all(this.el, \"form[\".concat(phxChange, \"]\")).filter(function (form) {\n        return _this48.ownsElement(form);\n      }).filter(function (form) {\n        return form.getAttribute(_this48.binding(PHX_AUTO_RECOVER)) !== \"ignore\";\n      }).filter(function (form) {\n        return template.content.querySelector(\"form[\".concat(phxChange, \"=\\\"\").concat(form.getAttribute(phxChange), \"\\\"]\"));\n      });\n    }\n  }, {\n    key: \"maybePushComponentsDestroyed\",\n    value: function maybePushComponentsDestroyed(destroyedCIDs) {\n      var _this49 = this;\n\n      var completelyDestroyedCIDs = destroyedCIDs.filter(function (cid) {\n        return DOM.findComponentNodeList(_this49.el, cid).length === 0;\n      });\n\n      if (completelyDestroyedCIDs.length > 0) {\n        this.pushWithReply(null, \"cids_destroyed\", {\n          cids: completelyDestroyedCIDs\n        }, function () {\n          _this49.rendered.pruneCIDs(completelyDestroyedCIDs);\n        });\n      }\n    }\n  }, {\n    key: \"ownsElement\",\n    value: function ownsElement(el) {\n      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), function (node) {\n        return node.id;\n      }) === this.id;\n    }\n  }, {\n    key: \"submitForm\",\n    value: function submitForm(form, targetCtx, phxEvent) {\n      var _this50 = this;\n\n      DOM.putPrivate(form, PHX_HAS_SUBMITTED, true);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, targetCtx, phxEvent, function () {\n        _this50.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n  }]);\n\n  return View;\n}();\nvar viewHookID = 1;\n\nvar ViewHook = /*#__PURE__*/function () {\n  _createClass(ViewHook, null, [{\n    key: \"makeID\",\n    value: function makeID() {\n      return viewHookID++;\n    }\n  }, {\n    key: \"elementID\",\n    value: function elementID(el) {\n      return el.phxHookId;\n    }\n  }]);\n\n  function ViewHook(view, el, callbacks) {\n    _classCallCheck(this, ViewHook);\n\n    this.__view = view;\n    this.__liveSocket = view.liveSocket;\n    this.__callbacks = callbacks;\n    this.__listeners = new Set();\n    this.el = el;\n    this.viewName = view.name();\n    this.el.phxHookId = this.constructor.makeID();\n\n    for (var key in this.__callbacks) {\n      this[key] = this.__callbacks[key];\n    }\n  }\n\n  _createClass(ViewHook, [{\n    key: \"pushEvent\",\n    value: function pushEvent(event) {\n      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var onReply = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      return this.__view.pushHookEvent(null, event, payload, onReply);\n    }\n  }, {\n    key: \"pushEventTo\",\n    value: function pushEventTo(phxTarget, event) {\n      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var onReply = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n      return this.__view.withinTargets(phxTarget, function (view, targetCtx) {\n        return view.pushHookEvent(targetCtx, event, payload, onReply);\n      });\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event, callback) {\n      var callbackRef = function callbackRef(customEvent, bypass) {\n        return bypass ? event : callback(customEvent.detail);\n      };\n\n      window.addEventListener(\"phx:hook:\".concat(event), callbackRef);\n\n      this.__listeners.add(callbackRef);\n\n      return callbackRef;\n    }\n  }, {\n    key: \"removeHandleEvent\",\n    value: function removeHandleEvent(callbackRef) {\n      var event = callbackRef(null, true);\n      window.removeEventListener(\"phx:hook:\".concat(event), callbackRef);\n\n      this.__listeners[\"delete\"](callbackRef);\n    }\n  }, {\n    key: \"__cleanup__\",\n    value: function __cleanup__() {\n      var _this51 = this;\n\n      this.__listeners.forEach(function (callbackRef) {\n        return _this51.removeHandleEvent(callbackRef);\n      });\n    }\n  }, {\n    key: \"__trigger__\",\n    value: function __trigger__(kind) {\n      var callback = this.__callbacks[kind];\n      callback && callback.call(this);\n    }\n  }]);\n\n  return ViewHook;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LiveSocket);\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js?./node_modules/babel-loader/lib");

/***/ }),

/***/ "./node_modules/morphdom/dist/morphdom-esm.js":
/*!****************************************************!*\
  !*** ./node_modules/morphdom/dist/morphdom-esm.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n      return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = Object.create(null);\n        var keyedRemovalList = [];\n\n        function addKeyedRemoval(key) {\n            keyedRemovalList.push(key);\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    // if we find a duplicate #id node in cache, replace `el` with cache value\n                    // and morph it to the child node.\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    } else {\n                      handleNodeAdded(curChild);\n                    }\n                } else {\n                  // recursively call for curChild and it's children to see if we find something in\n                  // fromNodesLookup\n                  handleNodeAdded(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                // MORPH\n                                morphEl(curFromNodeChild, curToNodeChild);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n                return;\n            }\n\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (morphdom);\n\n\n//# sourceURL=webpack://phoenix_live_view/./node_modules/morphdom/dist/morphdom-esm.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack://phoenix_live_view/(webpack)/buildin/global.js?");

/***/ })

/******/ });
});